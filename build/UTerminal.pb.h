// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: UTerminal.proto
// Protobuf C++ Version: 6.33.4

#ifndef UTerminal_2eproto_2epb_2eh
#define UTerminal_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_field_lite.h"
#include "google/protobuf/generated_enum_util.h"
#include "UT.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_UTerminal_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_UTerminal_2eproto {
  static const ::uint32_t offsets[];
};
namespace ut {
enum TerminalPacketType : int;
extern const uint32_t TerminalPacketType_internal_data_[];
class ConfigParams;
struct ConfigParamsDefaultTypeInternal;
extern ConfigParamsDefaultTypeInternal _ConfigParams_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<16> ConfigParams_class_data_;
class InitialPayload;
struct InitialPayloadDefaultTypeInternal;
extern InitialPayloadDefaultTypeInternal _InitialPayload_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<18> InitialPayload_class_data_;
class InitialResponse;
struct InitialResponseDefaultTypeInternal;
extern InitialResponseDefaultTypeInternal _InitialResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<19> InitialResponse_class_data_;
class PortForwardData;
struct PortForwardDataDefaultTypeInternal;
extern PortForwardDataDefaultTypeInternal _PortForwardData_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<19> PortForwardData_class_data_;
class PortForwardDestinationRequest;
struct PortForwardDestinationRequestDefaultTypeInternal;
extern PortForwardDestinationRequestDefaultTypeInternal _PortForwardDestinationRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<33> PortForwardDestinationRequest_class_data_;
class PortForwardDestinationResponse;
struct PortForwardDestinationResponseDefaultTypeInternal;
extern PortForwardDestinationResponseDefaultTypeInternal _PortForwardDestinationResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<34> PortForwardDestinationResponse_class_data_;
class PortForwardSourceRequest;
struct PortForwardSourceRequestDefaultTypeInternal;
extern PortForwardSourceRequestDefaultTypeInternal _PortForwardSourceRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<28> PortForwardSourceRequest_class_data_;
class PortForwardSourceResponse;
struct PortForwardSourceResponseDefaultTypeInternal;
extern PortForwardSourceResponseDefaultTypeInternal _PortForwardSourceResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<29> PortForwardSourceResponse_class_data_;
class TermInit;
struct TermInitDefaultTypeInternal;
extern TermInitDefaultTypeInternal _TermInit_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<12> TermInit_class_data_;
class TerminalBuffer;
struct TerminalBufferDefaultTypeInternal;
extern TerminalBufferDefaultTypeInternal _TerminalBuffer_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<18> TerminalBuffer_class_data_;
class TerminalInfo;
struct TerminalInfoDefaultTypeInternal;
extern TerminalInfoDefaultTypeInternal _TerminalInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<16> TerminalInfo_class_data_;
class TerminalUserInfo;
struct TerminalUserInfoDefaultTypeInternal;
extern TerminalUserInfoDefaultTypeInternal _TerminalUserInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataLite<20> TerminalUserInfo_class_data_;
}  // namespace ut
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::ut::TerminalPacketType_internal_data_>
    internal::EnumTraitsImpl::value<::ut::TerminalPacketType>;
}  // namespace protobuf
}  // namespace google

namespace ut {
enum TerminalPacketType : int {
  KEEP_ALIVE = 0,
  TERMINAL_BUFFER = 1,
  TERMINAL_INFO = 2,
  PORT_FORWARD_DESTINATION_REQUEST = 5,
  PORT_FORWARD_DESTINATION_RESPONSE = 6,
  PORT_FORWARD_DATA = 7,
  TERMINAL_USER_INFO = 8,
  TERMINAL_INIT = 9,
  JUMPHOST_INIT = 10,
};

extern const uint32_t TerminalPacketType_internal_data_[];
inline constexpr TerminalPacketType TerminalPacketType_MIN =
    static_cast<TerminalPacketType>(0);
inline constexpr TerminalPacketType TerminalPacketType_MAX =
    static_cast<TerminalPacketType>(10);
inline bool TerminalPacketType_IsValid(int value) {
  return 0 <= value && value <= 10 && ((2023u >> value) & 1) != 0;
}
inline constexpr int TerminalPacketType_ARRAYSIZE = 10 + 1;
const ::std::string& TerminalPacketType_Name(TerminalPacketType value);
template <typename T>
const ::std::string& TerminalPacketType_Name(T value) {
  static_assert(::std::is_same<T, TerminalPacketType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TerminalPacketType_Name().");
  return TerminalPacketType_Name(static_cast<TerminalPacketType>(value));
}
bool TerminalPacketType_Parse(
    ::absl::string_view name, TerminalPacketType* PROTOBUF_NONNULL value);

// ===================================================================


// -------------------------------------------------------------------

class TerminalUserInfo final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.TerminalUserInfo) */ {
 public:
  inline TerminalUserInfo() : TerminalUserInfo(nullptr) {}
  ~TerminalUserInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TerminalUserInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TerminalUserInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TerminalUserInfo(::google::protobuf::internal::ConstantInitialized);

  inline TerminalUserInfo(const TerminalUserInfo& from) : TerminalUserInfo(nullptr, from) {}
  inline TerminalUserInfo(TerminalUserInfo&& from) noexcept
      : TerminalUserInfo(nullptr, ::std::move(from)) {}
  inline TerminalUserInfo& operator=(const TerminalUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminalUserInfo& operator=(TerminalUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const TerminalUserInfo& default_instance() {
    return *reinterpret_cast<const TerminalUserInfo*>(
        &_TerminalUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(TerminalUserInfo& a, TerminalUserInfo& b) { a.Swap(&b); }
  inline void Swap(TerminalUserInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminalUserInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminalUserInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<TerminalUserInfo>(arena);
  }
  void CopyFrom(const TerminalUserInfo& from);
  void MergeFrom(const TerminalUserInfo& from) { TerminalUserInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TerminalUserInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.TerminalUserInfo"; }

  explicit TerminalUserInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TerminalUserInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TerminalUserInfo& from);
  TerminalUserInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TerminalUserInfo&& from) noexcept
      : TerminalUserInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kPasskeyFieldNumber = 2,
    kUidFieldNumber = 3,
    kGidFieldNumber = 4,
    kFdFieldNumber = 5,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // optional string passkey = 2;
  bool has_passkey() const;
  void clear_passkey() ;
  const ::std::string& passkey() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_passkey(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_passkey();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_passkey();
  void set_allocated_passkey(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_passkey() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_passkey(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_passkey();

  public:
  // optional int64 uid = 3;
  bool has_uid() const;
  void clear_uid() ;
  ::int64_t uid() const;
  void set_uid(::int64_t value);

  private:
  ::int64_t _internal_uid() const;
  void _internal_set_uid(::int64_t value);

  public:
  // optional int64 gid = 4;
  bool has_gid() const;
  void clear_gid() ;
  ::int64_t gid() const;
  void set_gid(::int64_t value);

  private:
  ::int64_t _internal_gid() const;
  void _internal_set_gid(::int64_t value);

  public:
  // optional int64 fd = 5;
  bool has_fd() const;
  void clear_fd() ;
  ::int64_t fd() const;
  void set_fd(::int64_t value);

  private:
  ::int64_t _internal_fd() const;
  void _internal_set_fd(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ut.TerminalUserInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TerminalUserInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr passkey_;
    ::int64_t uid_;
    ::int64_t gid_;
    ::int64_t fd_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<20> TerminalUserInfo_class_data_;
// -------------------------------------------------------------------

class TerminalInfo final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.TerminalInfo) */ {
 public:
  inline TerminalInfo() : TerminalInfo(nullptr) {}
  ~TerminalInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TerminalInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TerminalInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TerminalInfo(::google::protobuf::internal::ConstantInitialized);

  inline TerminalInfo(const TerminalInfo& from) : TerminalInfo(nullptr, from) {}
  inline TerminalInfo(TerminalInfo&& from) noexcept
      : TerminalInfo(nullptr, ::std::move(from)) {}
  inline TerminalInfo& operator=(const TerminalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminalInfo& operator=(TerminalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const TerminalInfo& default_instance() {
    return *reinterpret_cast<const TerminalInfo*>(
        &_TerminalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TerminalInfo& a, TerminalInfo& b) { a.Swap(&b); }
  inline void Swap(TerminalInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminalInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminalInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<TerminalInfo>(arena);
  }
  void CopyFrom(const TerminalInfo& from);
  void MergeFrom(const TerminalInfo& from) { TerminalInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TerminalInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.TerminalInfo"; }

  explicit TerminalInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TerminalInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TerminalInfo& from);
  TerminalInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TerminalInfo&& from) noexcept
      : TerminalInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kRowFieldNumber = 2,
    kColumnFieldNumber = 3,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // optional int32 row = 2;
  bool has_row() const;
  void clear_row() ;
  ::int32_t row() const;
  void set_row(::int32_t value);

  private:
  ::int32_t _internal_row() const;
  void _internal_set_row(::int32_t value);

  public:
  // optional int32 column = 3;
  bool has_column() const;
  void clear_column() ;
  ::int32_t column() const;
  void set_column(::int32_t value);

  private:
  ::int32_t _internal_column() const;
  void _internal_set_column(::int32_t value);

  public:
  // optional int32 width = 4;
  bool has_width() const;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // optional int32 height = 5;
  bool has_height() const;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ut.TerminalInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TerminalInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::int32_t row_;
    ::int32_t column_;
    ::int32_t width_;
    ::int32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<16> TerminalInfo_class_data_;
// -------------------------------------------------------------------

class TerminalBuffer final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.TerminalBuffer) */ {
 public:
  inline TerminalBuffer() : TerminalBuffer(nullptr) {}
  ~TerminalBuffer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TerminalBuffer* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TerminalBuffer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TerminalBuffer(::google::protobuf::internal::ConstantInitialized);

  inline TerminalBuffer(const TerminalBuffer& from) : TerminalBuffer(nullptr, from) {}
  inline TerminalBuffer(TerminalBuffer&& from) noexcept
      : TerminalBuffer(nullptr, ::std::move(from)) {}
  inline TerminalBuffer& operator=(const TerminalBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminalBuffer& operator=(TerminalBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const TerminalBuffer& default_instance() {
    return *reinterpret_cast<const TerminalBuffer*>(
        &_TerminalBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(TerminalBuffer& a, TerminalBuffer& b) { a.Swap(&b); }
  inline void Swap(TerminalBuffer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminalBuffer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminalBuffer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<TerminalBuffer>(arena);
  }
  void CopyFrom(const TerminalBuffer& from);
  void MergeFrom(const TerminalBuffer& from) { TerminalBuffer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TerminalBuffer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.TerminalBuffer"; }

  explicit TerminalBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TerminalBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TerminalBuffer& from);
  TerminalBuffer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TerminalBuffer&& from) noexcept
      : TerminalBuffer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBufferFieldNumber = 1,
  };
  // optional bytes buffer = 1;
  bool has_buffer() const;
  void clear_buffer() ;
  const ::std::string& buffer() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_buffer(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_buffer();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_buffer();
  void set_allocated_buffer(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_buffer() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_buffer();

  public:
  // @@protoc_insertion_point(class_scope:ut.TerminalBuffer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TerminalBuffer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr buffer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<18> TerminalBuffer_class_data_;
// -------------------------------------------------------------------

class TermInit final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.TermInit) */ {
 public:
  inline TermInit() : TermInit(nullptr) {}
  ~TermInit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TermInit* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TermInit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TermInit(::google::protobuf::internal::ConstantInitialized);

  inline TermInit(const TermInit& from) : TermInit(nullptr, from) {}
  inline TermInit(TermInit&& from) noexcept
      : TermInit(nullptr, ::std::move(from)) {}
  inline TermInit& operator=(const TermInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline TermInit& operator=(TermInit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const TermInit& default_instance() {
    return *reinterpret_cast<const TermInit*>(
        &_TermInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TermInit& a, TermInit& b) { a.Swap(&b); }
  inline void Swap(TermInit* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TermInit* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TermInit* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<TermInit>(arena);
  }
  void CopyFrom(const TermInit& from);
  void MergeFrom(const TermInit& from) { TermInit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TermInit* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.TermInit"; }

  explicit TermInit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TermInit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TermInit& from);
  TermInit(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TermInit&& from) noexcept
      : TermInit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvironmentnamesFieldNumber = 1,
    kEnvironmentvaluesFieldNumber = 2,
  };
  // repeated string environmentnames = 1;
  int environmentnames_size() const;
  private:
  int _internal_environmentnames_size() const;

  public:
  void clear_environmentnames() ;
  const ::std::string& environmentnames(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_environmentnames(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_environmentnames(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_environmentnames();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_environmentnames(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& environmentnames() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_environmentnames();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_environmentnames() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_environmentnames();

  public:
  // repeated string environmentvalues = 2;
  int environmentvalues_size() const;
  private:
  int _internal_environmentvalues_size() const;

  public:
  void clear_environmentvalues() ;
  const ::std::string& environmentvalues(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_environmentvalues(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_environmentvalues(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_environmentvalues();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_environmentvalues(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& environmentvalues() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_environmentvalues();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_environmentvalues() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_environmentvalues();

  public:
  // @@protoc_insertion_point(class_scope:ut.TermInit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TermInit& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> environmentnames_;
    ::google::protobuf::RepeatedPtrField<::std::string> environmentvalues_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<12> TermInit_class_data_;
// -------------------------------------------------------------------

class PortForwardSourceResponse final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.PortForwardSourceResponse) */ {
 public:
  inline PortForwardSourceResponse() : PortForwardSourceResponse(nullptr) {}
  ~PortForwardSourceResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PortForwardSourceResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PortForwardSourceResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortForwardSourceResponse(::google::protobuf::internal::ConstantInitialized);

  inline PortForwardSourceResponse(const PortForwardSourceResponse& from) : PortForwardSourceResponse(nullptr, from) {}
  inline PortForwardSourceResponse(PortForwardSourceResponse&& from) noexcept
      : PortForwardSourceResponse(nullptr, ::std::move(from)) {}
  inline PortForwardSourceResponse& operator=(const PortForwardSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortForwardSourceResponse& operator=(PortForwardSourceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const PortForwardSourceResponse& default_instance() {
    return *reinterpret_cast<const PortForwardSourceResponse*>(
        &_PortForwardSourceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PortForwardSourceResponse& a, PortForwardSourceResponse& b) { a.Swap(&b); }
  inline void Swap(PortForwardSourceResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortForwardSourceResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortForwardSourceResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PortForwardSourceResponse>(arena);
  }
  void CopyFrom(const PortForwardSourceResponse& from);
  void MergeFrom(const PortForwardSourceResponse& from) { PortForwardSourceResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PortForwardSourceResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.PortForwardSourceResponse"; }

  explicit PortForwardSourceResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PortForwardSourceResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PortForwardSourceResponse& from);
  PortForwardSourceResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PortForwardSourceResponse&& from) noexcept
      : PortForwardSourceResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:ut.PortForwardSourceResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PortForwardSourceResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<29> PortForwardSourceResponse_class_data_;
// -------------------------------------------------------------------

class PortForwardDestinationResponse final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.PortForwardDestinationResponse) */ {
 public:
  inline PortForwardDestinationResponse() : PortForwardDestinationResponse(nullptr) {}
  ~PortForwardDestinationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PortForwardDestinationResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PortForwardDestinationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortForwardDestinationResponse(::google::protobuf::internal::ConstantInitialized);

  inline PortForwardDestinationResponse(const PortForwardDestinationResponse& from) : PortForwardDestinationResponse(nullptr, from) {}
  inline PortForwardDestinationResponse(PortForwardDestinationResponse&& from) noexcept
      : PortForwardDestinationResponse(nullptr, ::std::move(from)) {}
  inline PortForwardDestinationResponse& operator=(const PortForwardDestinationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortForwardDestinationResponse& operator=(PortForwardDestinationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const PortForwardDestinationResponse& default_instance() {
    return *reinterpret_cast<const PortForwardDestinationResponse*>(
        &_PortForwardDestinationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PortForwardDestinationResponse& a, PortForwardDestinationResponse& b) { a.Swap(&b); }
  inline void Swap(PortForwardDestinationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortForwardDestinationResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortForwardDestinationResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PortForwardDestinationResponse>(arena);
  }
  void CopyFrom(const PortForwardDestinationResponse& from);
  void MergeFrom(const PortForwardDestinationResponse& from) { PortForwardDestinationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PortForwardDestinationResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.PortForwardDestinationResponse"; }

  explicit PortForwardDestinationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PortForwardDestinationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PortForwardDestinationResponse& from);
  PortForwardDestinationResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PortForwardDestinationResponse&& from) noexcept
      : PortForwardDestinationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 3,
    kClientfdFieldNumber = 1,
    kSocketidFieldNumber = 2,
  };
  // optional string error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // optional int32 clientfd = 1;
  bool has_clientfd() const;
  void clear_clientfd() ;
  ::int32_t clientfd() const;
  void set_clientfd(::int32_t value);

  private:
  ::int32_t _internal_clientfd() const;
  void _internal_set_clientfd(::int32_t value);

  public:
  // optional int32 socketid = 2;
  bool has_socketid() const;
  void clear_socketid() ;
  ::int32_t socketid() const;
  void set_socketid(::int32_t value);

  private:
  ::int32_t _internal_socketid() const;
  void _internal_set_socketid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ut.PortForwardDestinationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PortForwardDestinationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::int32_t clientfd_;
    ::int32_t socketid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<34> PortForwardDestinationResponse_class_data_;
// -------------------------------------------------------------------

class PortForwardData final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.PortForwardData) */ {
 public:
  inline PortForwardData() : PortForwardData(nullptr) {}
  ~PortForwardData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PortForwardData* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PortForwardData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortForwardData(::google::protobuf::internal::ConstantInitialized);

  inline PortForwardData(const PortForwardData& from) : PortForwardData(nullptr, from) {}
  inline PortForwardData(PortForwardData&& from) noexcept
      : PortForwardData(nullptr, ::std::move(from)) {}
  inline PortForwardData& operator=(const PortForwardData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortForwardData& operator=(PortForwardData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const PortForwardData& default_instance() {
    return *reinterpret_cast<const PortForwardData*>(
        &_PortForwardData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PortForwardData& a, PortForwardData& b) { a.Swap(&b); }
  inline void Swap(PortForwardData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortForwardData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortForwardData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PortForwardData>(arena);
  }
  void CopyFrom(const PortForwardData& from);
  void MergeFrom(const PortForwardData& from) { PortForwardData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PortForwardData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.PortForwardData"; }

  explicit PortForwardData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PortForwardData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PortForwardData& from);
  PortForwardData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PortForwardData&& from) noexcept
      : PortForwardData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBufferFieldNumber = 3,
    kErrorFieldNumber = 4,
    kSocketidFieldNumber = 2,
    kSourcetodestinationFieldNumber = 1,
    kClosedFieldNumber = 5,
  };
  // optional bytes buffer = 3;
  bool has_buffer() const;
  void clear_buffer() ;
  const ::std::string& buffer() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_buffer(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_buffer();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_buffer();
  void set_allocated_buffer(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_buffer() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_buffer();

  public:
  // optional string error = 4;
  bool has_error() const;
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // optional int32 socketid = 2;
  bool has_socketid() const;
  void clear_socketid() ;
  ::int32_t socketid() const;
  void set_socketid(::int32_t value);

  private:
  ::int32_t _internal_socketid() const;
  void _internal_set_socketid(::int32_t value);

  public:
  // optional bool sourcetodestination = 1;
  bool has_sourcetodestination() const;
  void clear_sourcetodestination() ;
  bool sourcetodestination() const;
  void set_sourcetodestination(bool value);

  private:
  bool _internal_sourcetodestination() const;
  void _internal_set_sourcetodestination(bool value);

  public:
  // optional bool closed = 5;
  bool has_closed() const;
  void clear_closed() ;
  bool closed() const;
  void set_closed(bool value);

  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ut.PortForwardData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PortForwardData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr buffer_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::int32_t socketid_;
    bool sourcetodestination_;
    bool closed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<19> PortForwardData_class_data_;
// -------------------------------------------------------------------

class InitialResponse final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.InitialResponse) */ {
 public:
  inline InitialResponse() : InitialResponse(nullptr) {}
  ~InitialResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InitialResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InitialResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitialResponse(::google::protobuf::internal::ConstantInitialized);

  inline InitialResponse(const InitialResponse& from) : InitialResponse(nullptr, from) {}
  inline InitialResponse(InitialResponse&& from) noexcept
      : InitialResponse(nullptr, ::std::move(from)) {}
  inline InitialResponse& operator=(const InitialResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialResponse& operator=(InitialResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const InitialResponse& default_instance() {
    return *reinterpret_cast<const InitialResponse*>(
        &_InitialResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(InitialResponse& a, InitialResponse& b) { a.Swap(&b); }
  inline void Swap(InitialResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<InitialResponse>(arena);
  }
  void CopyFrom(const InitialResponse& from);
  void MergeFrom(const InitialResponse& from) { InitialResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InitialResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.InitialResponse"; }

  explicit InitialResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InitialResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InitialResponse& from);
  InitialResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InitialResponse&& from) noexcept
      : InitialResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:ut.InitialResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InitialResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<19> InitialResponse_class_data_;
// -------------------------------------------------------------------

// -------------------------------------------------------------------

class ConfigParams final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.ConfigParams) */ {
 public:
  inline ConfigParams() : ConfigParams(nullptr) {}
  ~ConfigParams() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConfigParams* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConfigParams));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigParams(::google::protobuf::internal::ConstantInitialized);

  inline ConfigParams(const ConfigParams& from) : ConfigParams(nullptr, from) {}
  inline ConfigParams(ConfigParams&& from) noexcept
      : ConfigParams(nullptr, ::std::move(from)) {}
  inline ConfigParams& operator=(const ConfigParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigParams& operator=(ConfigParams&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const ConfigParams& default_instance() {
    return *reinterpret_cast<const ConfigParams*>(
        &_ConfigParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ConfigParams& a, ConfigParams& b) { a.Swap(&b); }
  inline void Swap(ConfigParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigParams* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigParams* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ConfigParams>(arena);
  }
  void CopyFrom(const ConfigParams& from);
  void MergeFrom(const ConfigParams& from) { ConfigParams::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConfigParams* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.ConfigParams"; }

  explicit ConfigParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConfigParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConfigParams& from);
  ConfigParams(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConfigParams&& from) noexcept
      : ConfigParams(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVlevelFieldNumber = 1,
    kMinloglevelFieldNumber = 2,
  };
  // optional int32 vlevel = 1;
  bool has_vlevel() const;
  void clear_vlevel() ;
  ::int32_t vlevel() const;
  void set_vlevel(::int32_t value);

  private:
  ::int32_t _internal_vlevel() const;
  void _internal_set_vlevel(::int32_t value);

  public:
  // optional int32 minloglevel = 2;
  bool has_minloglevel() const;
  void clear_minloglevel() ;
  ::int32_t minloglevel() const;
  void set_minloglevel(::int32_t value);

  private:
  ::int32_t _internal_minloglevel() const;
  void _internal_set_minloglevel(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ut.ConfigParams)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConfigParams& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t vlevel_;
    ::int32_t minloglevel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<16> ConfigParams_class_data_;
// -------------------------------------------------------------------

class PortForwardSourceRequest final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.PortForwardSourceRequest) */ {
 public:
  inline PortForwardSourceRequest() : PortForwardSourceRequest(nullptr) {}
  ~PortForwardSourceRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PortForwardSourceRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PortForwardSourceRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortForwardSourceRequest(::google::protobuf::internal::ConstantInitialized);

  inline PortForwardSourceRequest(const PortForwardSourceRequest& from) : PortForwardSourceRequest(nullptr, from) {}
  inline PortForwardSourceRequest(PortForwardSourceRequest&& from) noexcept
      : PortForwardSourceRequest(nullptr, ::std::move(from)) {}
  inline PortForwardSourceRequest& operator=(const PortForwardSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortForwardSourceRequest& operator=(PortForwardSourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const PortForwardSourceRequest& default_instance() {
    return *reinterpret_cast<const PortForwardSourceRequest*>(
        &_PortForwardSourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PortForwardSourceRequest& a, PortForwardSourceRequest& b) { a.Swap(&b); }
  inline void Swap(PortForwardSourceRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortForwardSourceRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortForwardSourceRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PortForwardSourceRequest>(arena);
  }
  void CopyFrom(const PortForwardSourceRequest& from);
  void MergeFrom(const PortForwardSourceRequest& from) { PortForwardSourceRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PortForwardSourceRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.PortForwardSourceRequest"; }

  explicit PortForwardSourceRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PortForwardSourceRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PortForwardSourceRequest& from);
  PortForwardSourceRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PortForwardSourceRequest&& from) noexcept
      : PortForwardSourceRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvironmentvariableFieldNumber = 3,
    kSourceFieldNumber = 1,
    kDestinationFieldNumber = 2,
  };
  // optional string environmentvariable = 3;
  bool has_environmentvariable() const;
  void clear_environmentvariable() ;
  const ::std::string& environmentvariable() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_environmentvariable(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_environmentvariable();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_environmentvariable();
  void set_allocated_environmentvariable(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_environmentvariable() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_environmentvariable(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_environmentvariable();

  public:
  // optional .ut.SocketEndpoint source = 1;
  bool has_source() const;
  void clear_source() ;
  const ::ut::SocketEndpoint& source() const;
  [[nodiscard]] ::ut::SocketEndpoint* PROTOBUF_NULLABLE release_source();
  ::ut::SocketEndpoint* PROTOBUF_NONNULL mutable_source();
  void set_allocated_source(::ut::SocketEndpoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_source(::ut::SocketEndpoint* PROTOBUF_NULLABLE value);
  ::ut::SocketEndpoint* PROTOBUF_NULLABLE unsafe_arena_release_source();

  private:
  const ::ut::SocketEndpoint& _internal_source() const;
  ::ut::SocketEndpoint* PROTOBUF_NONNULL _internal_mutable_source();

  public:
  // optional .ut.SocketEndpoint destination = 2;
  bool has_destination() const;
  void clear_destination() ;
  const ::ut::SocketEndpoint& destination() const;
  [[nodiscard]] ::ut::SocketEndpoint* PROTOBUF_NULLABLE release_destination();
  ::ut::SocketEndpoint* PROTOBUF_NONNULL mutable_destination();
  void set_allocated_destination(::ut::SocketEndpoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_destination(::ut::SocketEndpoint* PROTOBUF_NULLABLE value);
  ::ut::SocketEndpoint* PROTOBUF_NULLABLE unsafe_arena_release_destination();

  private:
  const ::ut::SocketEndpoint& _internal_destination() const;
  ::ut::SocketEndpoint* PROTOBUF_NONNULL _internal_mutable_destination();

  public:
  // @@protoc_insertion_point(class_scope:ut.PortForwardSourceRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PortForwardSourceRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr environmentvariable_;
    ::ut::SocketEndpoint* PROTOBUF_NULLABLE source_;
    ::ut::SocketEndpoint* PROTOBUF_NULLABLE destination_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<28> PortForwardSourceRequest_class_data_;
// -------------------------------------------------------------------

class PortForwardDestinationRequest final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.PortForwardDestinationRequest) */ {
 public:
  inline PortForwardDestinationRequest() : PortForwardDestinationRequest(nullptr) {}
  ~PortForwardDestinationRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PortForwardDestinationRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PortForwardDestinationRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortForwardDestinationRequest(::google::protobuf::internal::ConstantInitialized);

  inline PortForwardDestinationRequest(const PortForwardDestinationRequest& from) : PortForwardDestinationRequest(nullptr, from) {}
  inline PortForwardDestinationRequest(PortForwardDestinationRequest&& from) noexcept
      : PortForwardDestinationRequest(nullptr, ::std::move(from)) {}
  inline PortForwardDestinationRequest& operator=(const PortForwardDestinationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortForwardDestinationRequest& operator=(PortForwardDestinationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const PortForwardDestinationRequest& default_instance() {
    return *reinterpret_cast<const PortForwardDestinationRequest*>(
        &_PortForwardDestinationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PortForwardDestinationRequest& a, PortForwardDestinationRequest& b) { a.Swap(&b); }
  inline void Swap(PortForwardDestinationRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortForwardDestinationRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortForwardDestinationRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PortForwardDestinationRequest>(arena);
  }
  void CopyFrom(const PortForwardDestinationRequest& from);
  void MergeFrom(const PortForwardDestinationRequest& from) { PortForwardDestinationRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PortForwardDestinationRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.PortForwardDestinationRequest"; }

  explicit PortForwardDestinationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PortForwardDestinationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PortForwardDestinationRequest& from);
  PortForwardDestinationRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PortForwardDestinationRequest&& from) noexcept
      : PortForwardDestinationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDestinationFieldNumber = 1,
    kFdFieldNumber = 2,
  };
  // optional .ut.SocketEndpoint destination = 1;
  bool has_destination() const;
  void clear_destination() ;
  const ::ut::SocketEndpoint& destination() const;
  [[nodiscard]] ::ut::SocketEndpoint* PROTOBUF_NULLABLE release_destination();
  ::ut::SocketEndpoint* PROTOBUF_NONNULL mutable_destination();
  void set_allocated_destination(::ut::SocketEndpoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_destination(::ut::SocketEndpoint* PROTOBUF_NULLABLE value);
  ::ut::SocketEndpoint* PROTOBUF_NULLABLE unsafe_arena_release_destination();

  private:
  const ::ut::SocketEndpoint& _internal_destination() const;
  ::ut::SocketEndpoint* PROTOBUF_NONNULL _internal_mutable_destination();

  public:
  // optional int32 fd = 2;
  bool has_fd() const;
  void clear_fd() ;
  ::int32_t fd() const;
  void set_fd(::int32_t value);

  private:
  ::int32_t _internal_fd() const;
  void _internal_set_fd(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ut.PortForwardDestinationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PortForwardDestinationRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::ut::SocketEndpoint* PROTOBUF_NULLABLE destination_;
    ::int32_t fd_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<33> PortForwardDestinationRequest_class_data_;
// -------------------------------------------------------------------

class InitialPayload final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ut.InitialPayload) */ {
 public:
  inline InitialPayload() : InitialPayload(nullptr) {}
  ~InitialPayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InitialPayload* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InitialPayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitialPayload(::google::protobuf::internal::ConstantInitialized);

  inline InitialPayload(const InitialPayload& from) : InitialPayload(nullptr, from) {}
  inline InitialPayload(InitialPayload&& from) noexcept
      : InitialPayload(nullptr, ::std::move(from)) {}
  inline InitialPayload& operator=(const InitialPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialPayload& operator=(InitialPayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline ::std::string* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::std::string>();
  }

  static const InitialPayload& default_instance() {
    return *reinterpret_cast<const InitialPayload*>(
        &_InitialPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(InitialPayload& a, InitialPayload& b) { a.Swap(&b); }
  inline void Swap(InitialPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialPayload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<InitialPayload>(arena);
  }
  void CopyFrom(const InitialPayload& from);
  void MergeFrom(const InitialPayload& from) { InitialPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InitialPayload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ut.InitialPayload"; }

  explicit InitialPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InitialPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InitialPayload& from);
  InitialPayload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InitialPayload&& from) noexcept
      : InitialPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReversetunnelsFieldNumber = 2,
    kJumphostFieldNumber = 1,
    kEnvironmentvariablesFieldNumber = 3,
  };
  // repeated .ut.PortForwardSourceRequest reversetunnels = 2;
  int reversetunnels_size() const;
  private:
  int _internal_reversetunnels_size() const;

  public:
  void clear_reversetunnels() ;
  ::ut::PortForwardSourceRequest* PROTOBUF_NONNULL mutable_reversetunnels(int index);
  ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>* PROTOBUF_NONNULL mutable_reversetunnels();

  private:
  const ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>& _internal_reversetunnels() const;
  ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>* PROTOBUF_NONNULL _internal_mutable_reversetunnels();
  public:
  const ::ut::PortForwardSourceRequest& reversetunnels(int index) const;
  ::ut::PortForwardSourceRequest* PROTOBUF_NONNULL add_reversetunnels();
  const ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>& reversetunnels() const;
  // optional bool jumphost = 1 [default = false];
  bool has_jumphost() const;
  void clear_jumphost() ;
  bool jumphost() const;
  void set_jumphost(bool value);

  private:
  bool _internal_jumphost() const;
  void _internal_set_jumphost(bool value);

  public:
  // map<string, string> environmentvariables = 3;
  int environmentvariables_size() const;
  private:
  int _internal_environmentvariables_size() const;

  public:
  void clear_environmentvariables() ;
  const ::google::protobuf::Map<::std::string, ::std::string>& environmentvariables() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL mutable_environmentvariables();

  private:
  const ::google::protobuf::Map<::std::string, ::std::string>& _internal_environmentvariables() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL _internal_mutable_environmentvariables();

  public:
  // @@protoc_insertion_point(class_scope:ut.InitialPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InitialPayload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ut::PortForwardSourceRequest > reversetunnels_;
    bool jumphost_;
    ::google::protobuf::internal::MapFieldLite<::std::string, ::std::string> environmentvariables_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UTerminal_2eproto;
};

extern const ::google::protobuf::internal::ClassDataLite<18> InitialPayload_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TerminalBuffer

// optional bytes buffer = 1;
inline bool TerminalBuffer::has_buffer() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void TerminalBuffer::clear_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buffer_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TerminalBuffer::buffer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.TerminalBuffer.buffer)
  return _internal_buffer();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TerminalBuffer::set_buffer(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.buffer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.TerminalBuffer.buffer)
}
inline ::std::string* PROTOBUF_NONNULL TerminalBuffer::mutable_buffer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:ut.TerminalBuffer.buffer)
  return _s;
}
inline const ::std::string& TerminalBuffer::_internal_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buffer_.Get();
}
inline void TerminalBuffer::_internal_set_buffer(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buffer_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TerminalBuffer::_internal_mutable_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.buffer_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TerminalBuffer::release_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.TerminalBuffer.buffer)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.buffer_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.buffer_.Set("", GetArena());
  }
  return released;
}
inline void TerminalBuffer::set_allocated_buffer(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.buffer_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.TerminalBuffer.buffer)
}

// -------------------------------------------------------------------

// TerminalInfo

// optional string id = 1;
inline bool TerminalInfo::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void TerminalInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TerminalInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.TerminalInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TerminalInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.TerminalInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL TerminalInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ut.TerminalInfo.id)
  return _s;
}
inline const ::std::string& TerminalInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void TerminalInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TerminalInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TerminalInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.TerminalInfo.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void TerminalInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.TerminalInfo.id)
}

// optional int32 row = 2;
inline bool TerminalInfo::has_row() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void TerminalInfo::clear_row() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.row_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t TerminalInfo::row() const {
  // @@protoc_insertion_point(field_get:ut.TerminalInfo.row)
  return _internal_row();
}
inline void TerminalInfo::set_row(::int32_t value) {
  _internal_set_row(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ut.TerminalInfo.row)
}
inline ::int32_t TerminalInfo::_internal_row() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.row_;
}
inline void TerminalInfo::_internal_set_row(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.row_ = value;
}

// optional int32 column = 3;
inline bool TerminalInfo::has_column() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void TerminalInfo::clear_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t TerminalInfo::column() const {
  // @@protoc_insertion_point(field_get:ut.TerminalInfo.column)
  return _internal_column();
}
inline void TerminalInfo::set_column(::int32_t value) {
  _internal_set_column(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:ut.TerminalInfo.column)
}
inline ::int32_t TerminalInfo::_internal_column() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.column_;
}
inline void TerminalInfo::_internal_set_column(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_ = value;
}

// optional int32 width = 4;
inline bool TerminalInfo::has_width() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void TerminalInfo::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t TerminalInfo::width() const {
  // @@protoc_insertion_point(field_get:ut.TerminalInfo.width)
  return _internal_width();
}
inline void TerminalInfo::set_width(::int32_t value) {
  _internal_set_width(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:ut.TerminalInfo.width)
}
inline ::int32_t TerminalInfo::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void TerminalInfo::_internal_set_width(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// optional int32 height = 5;
inline bool TerminalInfo::has_height() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void TerminalInfo::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t TerminalInfo::height() const {
  // @@protoc_insertion_point(field_get:ut.TerminalInfo.height)
  return _internal_height();
}
inline void TerminalInfo::set_height(::int32_t value) {
  _internal_set_height(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:ut.TerminalInfo.height)
}
inline ::int32_t TerminalInfo::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void TerminalInfo::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// PortForwardSourceRequest

// optional .ut.SocketEndpoint source = 1;
inline bool PortForwardSourceRequest::has_source() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline const ::ut::SocketEndpoint& PortForwardSourceRequest::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ut::SocketEndpoint* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::ut::SocketEndpoint&>(::ut::_SocketEndpoint_default_instance_);
}
inline const ::ut::SocketEndpoint& PortForwardSourceRequest::source() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardSourceRequest.source)
  return _internal_source();
}
inline void PortForwardSourceRequest::unsafe_arena_set_allocated_source(
    ::ut::SocketEndpoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = reinterpret_cast<::ut::SocketEndpoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ut.PortForwardSourceRequest.source)
}
inline ::ut::SocketEndpoint* PROTOBUF_NULLABLE PortForwardSourceRequest::release_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::ut::SocketEndpoint* released = _impl_.source_;
  _impl_.source_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ut::SocketEndpoint* PROTOBUF_NULLABLE PortForwardSourceRequest::unsafe_arena_release_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardSourceRequest.source)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::ut::SocketEndpoint* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::ut::SocketEndpoint* PROTOBUF_NONNULL PortForwardSourceRequest::_internal_mutable_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::ut::SocketEndpoint>(GetArena());
    _impl_.source_ = reinterpret_cast<::ut::SocketEndpoint*>(p);
  }
  return _impl_.source_;
}
inline ::ut::SocketEndpoint* PROTOBUF_NONNULL PortForwardSourceRequest::mutable_source()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::ut::SocketEndpoint* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardSourceRequest.source)
  return _msg;
}
inline void PortForwardSourceRequest::set_allocated_source(::ut::SocketEndpoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.source_ = reinterpret_cast<::ut::SocketEndpoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardSourceRequest.source)
}

// optional .ut.SocketEndpoint destination = 2;
inline bool PortForwardSourceRequest::has_destination() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline const ::ut::SocketEndpoint& PortForwardSourceRequest::_internal_destination() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ut::SocketEndpoint* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::ut::SocketEndpoint&>(::ut::_SocketEndpoint_default_instance_);
}
inline const ::ut::SocketEndpoint& PortForwardSourceRequest::destination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardSourceRequest.destination)
  return _internal_destination();
}
inline void PortForwardSourceRequest::unsafe_arena_set_allocated_destination(
    ::ut::SocketEndpoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::ut::SocketEndpoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ut.PortForwardSourceRequest.destination)
}
inline ::ut::SocketEndpoint* PROTOBUF_NULLABLE PortForwardSourceRequest::release_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::ut::SocketEndpoint* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ut::SocketEndpoint* PROTOBUF_NULLABLE PortForwardSourceRequest::unsafe_arena_release_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardSourceRequest.destination)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::ut::SocketEndpoint* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::ut::SocketEndpoint* PROTOBUF_NONNULL PortForwardSourceRequest::_internal_mutable_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.destination_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::ut::SocketEndpoint>(GetArena());
    _impl_.destination_ = reinterpret_cast<::ut::SocketEndpoint*>(p);
  }
  return _impl_.destination_;
}
inline ::ut::SocketEndpoint* PROTOBUF_NONNULL PortForwardSourceRequest::mutable_destination()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::ut::SocketEndpoint* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardSourceRequest.destination)
  return _msg;
}
inline void PortForwardSourceRequest::set_allocated_destination(::ut::SocketEndpoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.destination_ = reinterpret_cast<::ut::SocketEndpoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardSourceRequest.destination)
}

// optional string environmentvariable = 3;
inline bool PortForwardSourceRequest::has_environmentvariable() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PortForwardSourceRequest::clear_environmentvariable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environmentvariable_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PortForwardSourceRequest::environmentvariable() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardSourceRequest.environmentvariable)
  return _internal_environmentvariable();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortForwardSourceRequest::set_environmentvariable(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.environmentvariable_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.PortForwardSourceRequest.environmentvariable)
}
inline ::std::string* PROTOBUF_NONNULL PortForwardSourceRequest::mutable_environmentvariable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_environmentvariable();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardSourceRequest.environmentvariable)
  return _s;
}
inline const ::std::string& PortForwardSourceRequest::_internal_environmentvariable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.environmentvariable_.Get();
}
inline void PortForwardSourceRequest::_internal_set_environmentvariable(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environmentvariable_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortForwardSourceRequest::_internal_mutable_environmentvariable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.environmentvariable_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortForwardSourceRequest::release_environmentvariable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardSourceRequest.environmentvariable)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.environmentvariable_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.environmentvariable_.Set("", GetArena());
  }
  return released;
}
inline void PortForwardSourceRequest::set_allocated_environmentvariable(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.environmentvariable_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.environmentvariable_.IsDefault()) {
    _impl_.environmentvariable_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardSourceRequest.environmentvariable)
}

// -------------------------------------------------------------------

// PortForwardSourceResponse

// optional string error = 1;
inline bool PortForwardSourceResponse::has_error() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PortForwardSourceResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PortForwardSourceResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardSourceResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortForwardSourceResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.PortForwardSourceResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL PortForwardSourceResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardSourceResponse.error)
  return _s;
}
inline const ::std::string& PortForwardSourceResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void PortForwardSourceResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortForwardSourceResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortForwardSourceResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardSourceResponse.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void PortForwardSourceResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardSourceResponse.error)
}

// -------------------------------------------------------------------

// PortForwardDestinationRequest

// optional .ut.SocketEndpoint destination = 1;
inline bool PortForwardDestinationRequest::has_destination() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline const ::ut::SocketEndpoint& PortForwardDestinationRequest::_internal_destination() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ut::SocketEndpoint* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::ut::SocketEndpoint&>(::ut::_SocketEndpoint_default_instance_);
}
inline const ::ut::SocketEndpoint& PortForwardDestinationRequest::destination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardDestinationRequest.destination)
  return _internal_destination();
}
inline void PortForwardDestinationRequest::unsafe_arena_set_allocated_destination(
    ::ut::SocketEndpoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::ut::SocketEndpoint*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ut.PortForwardDestinationRequest.destination)
}
inline ::ut::SocketEndpoint* PROTOBUF_NULLABLE PortForwardDestinationRequest::release_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::ut::SocketEndpoint* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ut::SocketEndpoint* PROTOBUF_NULLABLE PortForwardDestinationRequest::unsafe_arena_release_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardDestinationRequest.destination)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::ut::SocketEndpoint* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::ut::SocketEndpoint* PROTOBUF_NONNULL PortForwardDestinationRequest::_internal_mutable_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.destination_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::ut::SocketEndpoint>(GetArena());
    _impl_.destination_ = reinterpret_cast<::ut::SocketEndpoint*>(p);
  }
  return _impl_.destination_;
}
inline ::ut::SocketEndpoint* PROTOBUF_NONNULL PortForwardDestinationRequest::mutable_destination()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::ut::SocketEndpoint* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardDestinationRequest.destination)
  return _msg;
}
inline void PortForwardDestinationRequest::set_allocated_destination(::ut::SocketEndpoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.destination_ = reinterpret_cast<::ut::SocketEndpoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardDestinationRequest.destination)
}

// optional int32 fd = 2;
inline bool PortForwardDestinationRequest::has_fd() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PortForwardDestinationRequest::clear_fd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fd_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PortForwardDestinationRequest::fd() const {
  // @@protoc_insertion_point(field_get:ut.PortForwardDestinationRequest.fd)
  return _internal_fd();
}
inline void PortForwardDestinationRequest::set_fd(::int32_t value) {
  _internal_set_fd(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ut.PortForwardDestinationRequest.fd)
}
inline ::int32_t PortForwardDestinationRequest::_internal_fd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fd_;
}
inline void PortForwardDestinationRequest::_internal_set_fd(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fd_ = value;
}

// -------------------------------------------------------------------

// PortForwardDestinationResponse

// optional int32 clientfd = 1;
inline bool PortForwardDestinationResponse::has_clientfd() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PortForwardDestinationResponse::clear_clientfd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.clientfd_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PortForwardDestinationResponse::clientfd() const {
  // @@protoc_insertion_point(field_get:ut.PortForwardDestinationResponse.clientfd)
  return _internal_clientfd();
}
inline void PortForwardDestinationResponse::set_clientfd(::int32_t value) {
  _internal_set_clientfd(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ut.PortForwardDestinationResponse.clientfd)
}
inline ::int32_t PortForwardDestinationResponse::_internal_clientfd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.clientfd_;
}
inline void PortForwardDestinationResponse::_internal_set_clientfd(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.clientfd_ = value;
}

// optional int32 socketid = 2;
inline bool PortForwardDestinationResponse::has_socketid() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void PortForwardDestinationResponse::clear_socketid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.socketid_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t PortForwardDestinationResponse::socketid() const {
  // @@protoc_insertion_point(field_get:ut.PortForwardDestinationResponse.socketid)
  return _internal_socketid();
}
inline void PortForwardDestinationResponse::set_socketid(::int32_t value) {
  _internal_set_socketid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:ut.PortForwardDestinationResponse.socketid)
}
inline ::int32_t PortForwardDestinationResponse::_internal_socketid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.socketid_;
}
inline void PortForwardDestinationResponse::_internal_set_socketid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.socketid_ = value;
}

// optional string error = 3;
inline bool PortForwardDestinationResponse::has_error() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PortForwardDestinationResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PortForwardDestinationResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardDestinationResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortForwardDestinationResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.PortForwardDestinationResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL PortForwardDestinationResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardDestinationResponse.error)
  return _s;
}
inline const ::std::string& PortForwardDestinationResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void PortForwardDestinationResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortForwardDestinationResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortForwardDestinationResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardDestinationResponse.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void PortForwardDestinationResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardDestinationResponse.error)
}

// -------------------------------------------------------------------

// PortForwardData

// optional bool sourcetodestination = 1;
inline bool PortForwardData::has_sourcetodestination() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void PortForwardData::clear_sourcetodestination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sourcetodestination_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool PortForwardData::sourcetodestination() const {
  // @@protoc_insertion_point(field_get:ut.PortForwardData.sourcetodestination)
  return _internal_sourcetodestination();
}
inline void PortForwardData::set_sourcetodestination(bool value) {
  _internal_set_sourcetodestination(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:ut.PortForwardData.sourcetodestination)
}
inline bool PortForwardData::_internal_sourcetodestination() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sourcetodestination_;
}
inline void PortForwardData::_internal_set_sourcetodestination(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sourcetodestination_ = value;
}

// optional int32 socketid = 2;
inline bool PortForwardData::has_socketid() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void PortForwardData::clear_socketid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.socketid_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t PortForwardData::socketid() const {
  // @@protoc_insertion_point(field_get:ut.PortForwardData.socketid)
  return _internal_socketid();
}
inline void PortForwardData::set_socketid(::int32_t value) {
  _internal_set_socketid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:ut.PortForwardData.socketid)
}
inline ::int32_t PortForwardData::_internal_socketid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.socketid_;
}
inline void PortForwardData::_internal_set_socketid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.socketid_ = value;
}

// optional bytes buffer = 3;
inline bool PortForwardData::has_buffer() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void PortForwardData::clear_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buffer_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PortForwardData::buffer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardData.buffer)
  return _internal_buffer();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortForwardData::set_buffer(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.buffer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.PortForwardData.buffer)
}
inline ::std::string* PROTOBUF_NONNULL PortForwardData::mutable_buffer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardData.buffer)
  return _s;
}
inline const ::std::string& PortForwardData::_internal_buffer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buffer_.Get();
}
inline void PortForwardData::_internal_set_buffer(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buffer_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortForwardData::_internal_mutable_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.buffer_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortForwardData::release_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardData.buffer)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.buffer_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.buffer_.Set("", GetArena());
  }
  return released;
}
inline void PortForwardData::set_allocated_buffer(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.buffer_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardData.buffer)
}

// optional string error = 4;
inline bool PortForwardData::has_error() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void PortForwardData::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& PortForwardData::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.PortForwardData.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortForwardData::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.PortForwardData.error)
}
inline ::std::string* PROTOBUF_NONNULL PortForwardData::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ut.PortForwardData.error)
  return _s;
}
inline const ::std::string& PortForwardData::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void PortForwardData::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortForwardData::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortForwardData::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.PortForwardData.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void PortForwardData::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.PortForwardData.error)
}

// optional bool closed = 5;
inline bool PortForwardData::has_closed() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void PortForwardData::clear_closed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.closed_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool PortForwardData::closed() const {
  // @@protoc_insertion_point(field_get:ut.PortForwardData.closed)
  return _internal_closed();
}
inline void PortForwardData::set_closed(bool value) {
  _internal_set_closed(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:ut.PortForwardData.closed)
}
inline bool PortForwardData::_internal_closed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.closed_;
}
inline void PortForwardData::_internal_set_closed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.closed_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InitialPayload

// optional bool jumphost = 1 [default = false];
inline bool InitialPayload::has_jumphost() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void InitialPayload::clear_jumphost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jumphost_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool InitialPayload::jumphost() const {
  // @@protoc_insertion_point(field_get:ut.InitialPayload.jumphost)
  return _internal_jumphost();
}
inline void InitialPayload::set_jumphost(bool value) {
  _internal_set_jumphost(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ut.InitialPayload.jumphost)
}
inline bool InitialPayload::_internal_jumphost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jumphost_;
}
inline void InitialPayload::_internal_set_jumphost(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jumphost_ = value;
}

// repeated .ut.PortForwardSourceRequest reversetunnels = 2;
inline int InitialPayload::_internal_reversetunnels_size() const {
  return _internal_reversetunnels().size();
}
inline int InitialPayload::reversetunnels_size() const {
  return _internal_reversetunnels_size();
}
inline void InitialPayload::clear_reversetunnels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reversetunnels_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::ut::PortForwardSourceRequest* PROTOBUF_NONNULL InitialPayload::mutable_reversetunnels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ut.InitialPayload.reversetunnels)
  return _internal_mutable_reversetunnels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>* PROTOBUF_NONNULL InitialPayload::mutable_reversetunnels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:ut.InitialPayload.reversetunnels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_reversetunnels();
}
inline const ::ut::PortForwardSourceRequest& InitialPayload::reversetunnels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.InitialPayload.reversetunnels)
  return _internal_reversetunnels().Get(index);
}
inline ::ut::PortForwardSourceRequest* PROTOBUF_NONNULL InitialPayload::add_reversetunnels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ut::PortForwardSourceRequest* _add =
      _internal_mutable_reversetunnels()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:ut.InitialPayload.reversetunnels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>& InitialPayload::reversetunnels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ut.InitialPayload.reversetunnels)
  return _internal_reversetunnels();
}
inline const ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>&
InitialPayload::_internal_reversetunnels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reversetunnels_;
}
inline ::google::protobuf::RepeatedPtrField<::ut::PortForwardSourceRequest>* PROTOBUF_NONNULL
InitialPayload::_internal_mutable_reversetunnels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.reversetunnels_;
}

// map<string, string> environmentvariables = 3;
inline int InitialPayload::_internal_environmentvariables_size() const {
  return _internal_environmentvariables().size();
}
inline int InitialPayload::environmentvariables_size() const {
  return _internal_environmentvariables_size();
}
inline void InitialPayload::clear_environmentvariables() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environmentvariables_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& InitialPayload::_internal_environmentvariables() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.environmentvariables_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& InitialPayload::environmentvariables() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:ut.InitialPayload.environmentvariables)
  return _internal_environmentvariables();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL InitialPayload::_internal_mutable_environmentvariables() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.environmentvariables_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL InitialPayload::mutable_environmentvariables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:ut.InitialPayload.environmentvariables)
  return _internal_mutable_environmentvariables();
}

// -------------------------------------------------------------------

// InitialResponse

// optional string error = 1;
inline bool InitialResponse::has_error() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void InitialResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& InitialResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.InitialResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitialResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.InitialResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL InitialResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ut.InitialResponse.error)
  return _s;
}
inline const ::std::string& InitialResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void InitialResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitialResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitialResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.InitialResponse.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void InitialResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.InitialResponse.error)
}

// -------------------------------------------------------------------

// ConfigParams

// optional int32 vlevel = 1;
inline bool ConfigParams::has_vlevel() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void ConfigParams::clear_vlevel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vlevel_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t ConfigParams::vlevel() const {
  // @@protoc_insertion_point(field_get:ut.ConfigParams.vlevel)
  return _internal_vlevel();
}
inline void ConfigParams::set_vlevel(::int32_t value) {
  _internal_set_vlevel(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:ut.ConfigParams.vlevel)
}
inline ::int32_t ConfigParams::_internal_vlevel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vlevel_;
}
inline void ConfigParams::_internal_set_vlevel(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vlevel_ = value;
}

// optional int32 minloglevel = 2;
inline bool ConfigParams::has_minloglevel() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void ConfigParams::clear_minloglevel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minloglevel_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t ConfigParams::minloglevel() const {
  // @@protoc_insertion_point(field_get:ut.ConfigParams.minloglevel)
  return _internal_minloglevel();
}
inline void ConfigParams::set_minloglevel(::int32_t value) {
  _internal_set_minloglevel(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ut.ConfigParams.minloglevel)
}
inline ::int32_t ConfigParams::_internal_minloglevel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.minloglevel_;
}
inline void ConfigParams::_internal_set_minloglevel(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minloglevel_ = value;
}

// -------------------------------------------------------------------

// TermInit

// repeated string environmentnames = 1;
inline int TermInit::_internal_environmentnames_size() const {
  return _internal_environmentnames().size();
}
inline int TermInit::environmentnames_size() const {
  return _internal_environmentnames_size();
}
inline void TermInit::clear_environmentnames() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environmentnames_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL TermInit::add_environmentnames()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_environmentnames()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:ut.TermInit.environmentnames)
  return _s;
}
inline const ::std::string& TermInit::environmentnames(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.TermInit.environmentnames)
  return _internal_environmentnames().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL TermInit::mutable_environmentnames(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ut.TermInit.environmentnames)
  return _internal_mutable_environmentnames()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TermInit::set_environmentnames(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_environmentnames()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:ut.TermInit.environmentnames)
}
template <typename Arg_, typename... Args_>
inline void TermInit::add_environmentnames(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_environmentnames(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:ut.TermInit.environmentnames)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& TermInit::environmentnames()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ut.TermInit.environmentnames)
  return _internal_environmentnames();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TermInit::mutable_environmentnames() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:ut.TermInit.environmentnames)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_environmentnames();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
TermInit::_internal_environmentnames() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.environmentnames_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TermInit::_internal_mutable_environmentnames() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.environmentnames_;
}

// repeated string environmentvalues = 2;
inline int TermInit::_internal_environmentvalues_size() const {
  return _internal_environmentvalues().size();
}
inline int TermInit::environmentvalues_size() const {
  return _internal_environmentvalues_size();
}
inline void TermInit::clear_environmentvalues() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environmentvalues_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::std::string* PROTOBUF_NONNULL TermInit::add_environmentvalues()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_environmentvalues()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add_mutable:ut.TermInit.environmentvalues)
  return _s;
}
inline const ::std::string& TermInit::environmentvalues(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.TermInit.environmentvalues)
  return _internal_environmentvalues().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL TermInit::mutable_environmentvalues(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ut.TermInit.environmentvalues)
  return _internal_mutable_environmentvalues()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TermInit::set_environmentvalues(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_environmentvalues()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:ut.TermInit.environmentvalues)
}
template <typename Arg_, typename... Args_>
inline void TermInit::add_environmentvalues(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_environmentvalues(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:ut.TermInit.environmentvalues)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& TermInit::environmentvalues()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ut.TermInit.environmentvalues)
  return _internal_environmentvalues();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TermInit::mutable_environmentvalues() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:ut.TermInit.environmentvalues)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_environmentvalues();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
TermInit::_internal_environmentvalues() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.environmentvalues_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
TermInit::_internal_mutable_environmentvalues() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.environmentvalues_;
}

// -------------------------------------------------------------------

// TerminalUserInfo

// optional string id = 1;
inline bool TerminalUserInfo::has_id() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  return value;
}
inline void TerminalUserInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TerminalUserInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.TerminalUserInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TerminalUserInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.TerminalUserInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL TerminalUserInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ut.TerminalUserInfo.id)
  return _s;
}
inline const ::std::string& TerminalUserInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void TerminalUserInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TerminalUserInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TerminalUserInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.TerminalUserInfo.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void TerminalUserInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.TerminalUserInfo.id)
}

// optional string passkey = 2;
inline bool TerminalUserInfo::has_passkey() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  return value;
}
inline void TerminalUserInfo::clear_passkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passkey_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& TerminalUserInfo::passkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ut.TerminalUserInfo.passkey)
  return _internal_passkey();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TerminalUserInfo::set_passkey(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.passkey_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ut.TerminalUserInfo.passkey)
}
inline ::std::string* PROTOBUF_NONNULL TerminalUserInfo::mutable_passkey()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_passkey();
  // @@protoc_insertion_point(field_mutable:ut.TerminalUserInfo.passkey)
  return _s;
}
inline const ::std::string& TerminalUserInfo::_internal_passkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.passkey_.Get();
}
inline void TerminalUserInfo::_internal_set_passkey(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passkey_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TerminalUserInfo::_internal_mutable_passkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.passkey_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TerminalUserInfo::release_passkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ut.TerminalUserInfo.passkey)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.passkey_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.passkey_.Set("", GetArena());
  }
  return released;
}
inline void TerminalUserInfo::set_allocated_passkey(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.passkey_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.passkey_.IsDefault()) {
    _impl_.passkey_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ut.TerminalUserInfo.passkey)
}

// optional int64 uid = 3;
inline bool TerminalUserInfo::has_uid() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  return value;
}
inline void TerminalUserInfo::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int64_t TerminalUserInfo::uid() const {
  // @@protoc_insertion_point(field_get:ut.TerminalUserInfo.uid)
  return _internal_uid();
}
inline void TerminalUserInfo::set_uid(::int64_t value) {
  _internal_set_uid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:ut.TerminalUserInfo.uid)
}
inline ::int64_t TerminalUserInfo::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_;
}
inline void TerminalUserInfo::_internal_set_uid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_ = value;
}

// optional int64 gid = 4;
inline bool TerminalUserInfo::has_gid() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  return value;
}
inline void TerminalUserInfo::clear_gid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int64_t TerminalUserInfo::gid() const {
  // @@protoc_insertion_point(field_get:ut.TerminalUserInfo.gid)
  return _internal_gid();
}
inline void TerminalUserInfo::set_gid(::int64_t value) {
  _internal_set_gid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:ut.TerminalUserInfo.gid)
}
inline ::int64_t TerminalUserInfo::_internal_gid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gid_;
}
inline void TerminalUserInfo::_internal_set_gid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gid_ = value;
}

// optional int64 fd = 5;
inline bool TerminalUserInfo::has_fd() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  return value;
}
inline void TerminalUserInfo::clear_fd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fd_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int64_t TerminalUserInfo::fd() const {
  // @@protoc_insertion_point(field_get:ut.TerminalUserInfo.fd)
  return _internal_fd();
}
inline void TerminalUserInfo::set_fd(::int64_t value) {
  _internal_set_fd(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:ut.TerminalUserInfo.fd)
}
inline ::int64_t TerminalUserInfo::_internal_fd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fd_;
}
inline void TerminalUserInfo::_internal_set_fd(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fd_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ut


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ut::TerminalPacketType> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // UTerminal_2eproto_2epb_2eh
