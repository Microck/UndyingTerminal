// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: UTerminal.proto
// Protobuf C++ Version: 6.33.4

#include "UTerminal.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace ut {

inline constexpr TerminalUserInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        passkey_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        uid_{::int64_t{0}},
        gid_{::int64_t{0}},
        fd_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR TerminalUserInfo::TerminalUserInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(TerminalUserInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TerminalUserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TerminalUserInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TerminalUserInfoDefaultTypeInternal() {}
  union {
    TerminalUserInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TerminalUserInfoDefaultTypeInternal _TerminalUserInfo_default_instance_;

inline constexpr TerminalInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        row_{0},
        column_{0},
        width_{0},
        height_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TerminalInfo::TerminalInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(TerminalInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TerminalInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TerminalInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TerminalInfoDefaultTypeInternal() {}
  union {
    TerminalInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TerminalInfoDefaultTypeInternal _TerminalInfo_default_instance_;

inline constexpr TerminalBuffer::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        buffer_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR TerminalBuffer::TerminalBuffer(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(TerminalBuffer_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TerminalBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TerminalBufferDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TerminalBufferDefaultTypeInternal() {}
  union {
    TerminalBuffer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TerminalBufferDefaultTypeInternal _TerminalBuffer_default_instance_;

inline constexpr TermInit::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        environmentnames_{},
        environmentvalues_{} {}

template <typename>
PROTOBUF_CONSTEXPR TermInit::TermInit(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(TermInit_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TermInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TermInitDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TermInitDefaultTypeInternal() {}
  union {
    TermInit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TermInitDefaultTypeInternal _TermInit_default_instance_;

inline constexpr PortForwardSourceResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR PortForwardSourceResponse::PortForwardSourceResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PortForwardSourceResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PortForwardSourceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortForwardSourceResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortForwardSourceResponseDefaultTypeInternal() {}
  union {
    PortForwardSourceResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortForwardSourceResponseDefaultTypeInternal _PortForwardSourceResponse_default_instance_;

inline constexpr PortForwardDestinationResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        clientfd_{0},
        socketid_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PortForwardDestinationResponse::PortForwardDestinationResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PortForwardDestinationResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PortForwardDestinationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortForwardDestinationResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortForwardDestinationResponseDefaultTypeInternal() {}
  union {
    PortForwardDestinationResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortForwardDestinationResponseDefaultTypeInternal _PortForwardDestinationResponse_default_instance_;

inline constexpr PortForwardData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        buffer_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        error_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        socketid_{0},
        sourcetodestination_{false},
        closed_{false} {}

template <typename>
PROTOBUF_CONSTEXPR PortForwardData::PortForwardData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PortForwardData_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PortForwardDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortForwardDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortForwardDataDefaultTypeInternal() {}
  union {
    PortForwardData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortForwardDataDefaultTypeInternal _PortForwardData_default_instance_;

inline constexpr InitialResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR InitialResponse::InitialResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(InitialResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InitialResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitialResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitialResponseDefaultTypeInternal() {}
  union {
    InitialResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitialResponseDefaultTypeInternal _InitialResponse_default_instance_;

inline constexpr ConfigParams::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vlevel_{0},
        minloglevel_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ConfigParams::ConfigParams(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(ConfigParams_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ConfigParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigParamsDefaultTypeInternal() {}
  union {
    ConfigParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigParamsDefaultTypeInternal _ConfigParams_default_instance_;

inline constexpr PortForwardSourceRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        environmentvariable_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        source_{nullptr},
        destination_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PortForwardSourceRequest::PortForwardSourceRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PortForwardSourceRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PortForwardSourceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortForwardSourceRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortForwardSourceRequestDefaultTypeInternal() {}
  union {
    PortForwardSourceRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortForwardSourceRequestDefaultTypeInternal _PortForwardSourceRequest_default_instance_;

inline constexpr PortForwardDestinationRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        destination_{nullptr},
        fd_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PortForwardDestinationRequest::PortForwardDestinationRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(PortForwardDestinationRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PortForwardDestinationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortForwardDestinationRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortForwardDestinationRequestDefaultTypeInternal() {}
  union {
    PortForwardDestinationRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortForwardDestinationRequestDefaultTypeInternal _PortForwardDestinationRequest_default_instance_;

inline constexpr InitialPayload::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reversetunnels_{},
        jumphost_{false},
        environmentvariables_{} {}

template <typename>
PROTOBUF_CONSTEXPR InitialPayload::InitialPayload(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(InitialPayload_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InitialPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitialPayloadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitialPayloadDefaultTypeInternal() {}
  union {
    InitialPayload _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitialPayloadDefaultTypeInternal _InitialPayload_default_instance_;
}  // namespace ut
namespace ut {
PROTOBUF_CONSTINIT const uint32_t TerminalPacketType_internal_data_[] = {
    196608u, 32u, 252u, };
static ::google::protobuf::internal::ExplicitlyConstructed<::std::string>
    TerminalPacketType_strings[9] = {};

static const char TerminalPacketType_names[] = {
    "JUMPHOST_INIT"
    "KEEP_ALIVE"
    "PORT_FORWARD_DATA"
    "PORT_FORWARD_DESTINATION_REQUEST"
    "PORT_FORWARD_DESTINATION_RESPONSE"
    "TERMINAL_BUFFER"
    "TERMINAL_INFO"
    "TERMINAL_INIT"
    "TERMINAL_USER_INFO"
};

static const ::google::protobuf::internal::EnumEntry TerminalPacketType_entries[] = {
    {{&TerminalPacketType_names[0], 13}, 10},
    {{&TerminalPacketType_names[13], 10}, 0},
    {{&TerminalPacketType_names[23], 17}, 7},
    {{&TerminalPacketType_names[40], 32}, 5},
    {{&TerminalPacketType_names[72], 33}, 6},
    {{&TerminalPacketType_names[105], 15}, 1},
    {{&TerminalPacketType_names[120], 13}, 2},
    {{&TerminalPacketType_names[133], 13}, 9},
    {{&TerminalPacketType_names[146], 18}, 8},
};

static const int TerminalPacketType_entries_by_number[] = {
    1,  // 0 -> KEEP_ALIVE
    5,  // 1 -> TERMINAL_BUFFER
    6,  // 2 -> TERMINAL_INFO
    3,  // 5 -> PORT_FORWARD_DESTINATION_REQUEST
    4,  // 6 -> PORT_FORWARD_DESTINATION_RESPONSE
    2,  // 7 -> PORT_FORWARD_DATA
    8,  // 8 -> TERMINAL_USER_INFO
    7,  // 9 -> TERMINAL_INIT
    0,  // 10 -> JUMPHOST_INIT
};

const ::std::string& TerminalPacketType_Name(TerminalPacketType value) {
  static const bool kDummy = ::google::protobuf::internal::InitializeEnumStrings(
      TerminalPacketType_entries, TerminalPacketType_entries_by_number, 9,
      TerminalPacketType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(TerminalPacketType_entries,
                                  TerminalPacketType_entries_by_number,
                                  9, value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString() : TerminalPacketType_strings[idx].get();
}

bool TerminalPacketType_Parse(::absl::string_view name, TerminalPacketType* PROTOBUF_NONNULL value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TerminalPacketType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<TerminalPacketType>(int_value);
  }
  return success;
}
// ===================================================================

class TerminalBuffer::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TerminalBuffer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TerminalBuffer, _impl_._has_bits_);
};

TerminalBuffer::TerminalBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TerminalBuffer_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.TerminalBuffer)
}
PROTOBUF_NDEBUG_INLINE TerminalBuffer::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::TerminalBuffer& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        buffer_(arena, from.buffer_) {}

TerminalBuffer::TerminalBuffer(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TerminalBuffer& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TerminalBuffer_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TerminalBuffer* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:ut.TerminalBuffer)
}
PROTOBUF_NDEBUG_INLINE TerminalBuffer::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        buffer_(arena) {}

inline void TerminalBuffer::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TerminalBuffer::~TerminalBuffer() {
  // @@protoc_insertion_point(destructor:ut.TerminalBuffer)
  SharedDtor(*this);
}
inline void TerminalBuffer::SharedDtor(MessageLite& self) {
  TerminalBuffer& this_ = static_cast<TerminalBuffer&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.buffer_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TerminalBuffer::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TerminalBuffer(arena);
}
constexpr auto TerminalBuffer::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TerminalBuffer),
                                            alignof(TerminalBuffer));
}
constexpr auto TerminalBuffer::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<18>{
      {
          &_TerminalBuffer_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TerminalBuffer::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<TerminalBuffer>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TerminalBuffer::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<TerminalBuffer>(), &TerminalBuffer::ByteSizeLong,
              &TerminalBuffer::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TerminalBuffer, _impl_._cached_size_),
          true,
      },
      "ut.TerminalBuffer",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<18> TerminalBuffer_class_data_ =
    TerminalBuffer::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TerminalBuffer::GetClassData() const {
  return TerminalBuffer_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
TerminalBuffer::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TerminalBuffer, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TerminalBuffer_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::TerminalBuffer>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bytes buffer = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TerminalBuffer, _impl_.buffer_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes buffer = 1;
    {PROTOBUF_FIELD_OFFSET(TerminalBuffer, _impl_.buffer_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void TerminalBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.TerminalBuffer)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.buffer_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TerminalBuffer::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TerminalBuffer& this_ = static_cast<const TerminalBuffer&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TerminalBuffer::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TerminalBuffer& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.TerminalBuffer)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes buffer = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_buffer();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.TerminalBuffer)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TerminalBuffer::ByteSizeLong(const MessageLite& base) {
  const TerminalBuffer& this_ = static_cast<const TerminalBuffer&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TerminalBuffer::ByteSizeLong() const {
  const TerminalBuffer& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.TerminalBuffer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional bytes buffer = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_buffer());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void TerminalBuffer::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TerminalBuffer*>(&to_msg);
  auto& from = static_cast<const TerminalBuffer&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.TerminalBuffer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_internal_set_buffer(from._internal_buffer());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void TerminalBuffer::CopyFrom(const TerminalBuffer& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.TerminalBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TerminalBuffer::InternalSwap(TerminalBuffer* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.buffer_, &other->_impl_.buffer_, arena);
}

// ===================================================================

class TerminalInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TerminalInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_._has_bits_);
};

TerminalInfo::TerminalInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TerminalInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.TerminalInfo)
}
PROTOBUF_NDEBUG_INLINE TerminalInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::TerminalInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_) {}

TerminalInfo::TerminalInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TerminalInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TerminalInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TerminalInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, row_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, row_),
           offsetof(Impl_, height_) -
               offsetof(Impl_, row_) +
               sizeof(Impl_::height_));

  // @@protoc_insertion_point(copy_constructor:ut.TerminalInfo)
}
PROTOBUF_NDEBUG_INLINE TerminalInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        id_(arena) {}

inline void TerminalInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, row_),
           0,
           offsetof(Impl_, height_) -
               offsetof(Impl_, row_) +
               sizeof(Impl_::height_));
}
TerminalInfo::~TerminalInfo() {
  // @@protoc_insertion_point(destructor:ut.TerminalInfo)
  SharedDtor(*this);
}
inline void TerminalInfo::SharedDtor(MessageLite& self) {
  TerminalInfo& this_ = static_cast<TerminalInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TerminalInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TerminalInfo(arena);
}
constexpr auto TerminalInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TerminalInfo),
                                            alignof(TerminalInfo));
}
constexpr auto TerminalInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<16>{
      {
          &_TerminalInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TerminalInfo::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<TerminalInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TerminalInfo::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<TerminalInfo>(), &TerminalInfo::ByteSizeLong,
              &TerminalInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_._cached_size_),
          true,
      },
      "ut.TerminalInfo",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<16> TerminalInfo_class_data_ =
    TerminalInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TerminalInfo::GetClassData() const {
  return TerminalInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
TerminalInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TerminalInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::TerminalInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.id_)}},
    // optional int32 row = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.row_)}},
    // optional int32 column = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.column_)}},
    // optional int32 width = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.width_)}},
    // optional int32 height = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.height_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string id = 1;
    {PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 row = 2;
    {PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.row_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 column = 3;
    {PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.column_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 width = 4;
    {PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.width_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 height = 5;
    {PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.height_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void TerminalInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.TerminalInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001eU)) {
    ::memset(&_impl_.row_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.row_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TerminalInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TerminalInfo& this_ = static_cast<const TerminalInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TerminalInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TerminalInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.TerminalInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 row = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_row(), target);
  }

  // optional int32 column = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
            stream, this_._internal_column(), target);
  }

  // optional int32 width = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
            stream, this_._internal_width(), target);
  }

  // optional int32 height = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<5>(
            stream, this_._internal_height(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.TerminalInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TerminalInfo::ByteSizeLong(const MessageLite& base) {
  const TerminalInfo& this_ = static_cast<const TerminalInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TerminalInfo::ByteSizeLong() const {
  const TerminalInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.TerminalInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // optional string id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_id());
    }
    // optional int32 row = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_row());
    }
    // optional int32 column = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_column());
    }
    // optional int32 width = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_width());
    }
    // optional int32 height = 5;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_height());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void TerminalInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TerminalInfo*>(&to_msg);
  auto& from = static_cast<const TerminalInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.TerminalInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_id(from._internal_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.row_ = from._impl_.row_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.column_ = from._impl_.column_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.height_ = from._impl_.height_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void TerminalInfo::CopyFrom(const TerminalInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.TerminalInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TerminalInfo::InternalSwap(TerminalInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.height_)
      + sizeof(TerminalInfo::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(TerminalInfo, _impl_.row_)>(
          reinterpret_cast<char*>(&_impl_.row_),
          reinterpret_cast<char*>(&other->_impl_.row_));
}

// ===================================================================

class PortForwardSourceRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PortForwardSourceRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_._has_bits_);
};

void PortForwardSourceRequest::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
void PortForwardSourceRequest::clear_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.destination_ != nullptr) _impl_.destination_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
PortForwardSourceRequest::PortForwardSourceRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardSourceRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.PortForwardSourceRequest)
}
PROTOBUF_NDEBUG_INLINE PortForwardSourceRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::PortForwardSourceRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        environmentvariable_(arena, from.environmentvariable_) {}

PortForwardSourceRequest::PortForwardSourceRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PortForwardSourceRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardSourceRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PortForwardSourceRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.source_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.source_)
                : nullptr;
  _impl_.destination_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.destination_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:ut.PortForwardSourceRequest)
}
PROTOBUF_NDEBUG_INLINE PortForwardSourceRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        environmentvariable_(arena) {}

inline void PortForwardSourceRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, source_),
           0,
           offsetof(Impl_, destination_) -
               offsetof(Impl_, source_) +
               sizeof(Impl_::destination_));
}
PortForwardSourceRequest::~PortForwardSourceRequest() {
  // @@protoc_insertion_point(destructor:ut.PortForwardSourceRequest)
  SharedDtor(*this);
}
inline void PortForwardSourceRequest::SharedDtor(MessageLite& self) {
  PortForwardSourceRequest& this_ = static_cast<PortForwardSourceRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.environmentvariable_.Destroy();
  delete this_._impl_.source_;
  delete this_._impl_.destination_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PortForwardSourceRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PortForwardSourceRequest(arena);
}
constexpr auto PortForwardSourceRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PortForwardSourceRequest),
                                            alignof(PortForwardSourceRequest));
}
constexpr auto PortForwardSourceRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<28>{
      {
          &_PortForwardSourceRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PortForwardSourceRequest::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PortForwardSourceRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PortForwardSourceRequest::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PortForwardSourceRequest>(), &PortForwardSourceRequest::ByteSizeLong,
              &PortForwardSourceRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_._cached_size_),
          true,
      },
      "ut.PortForwardSourceRequest",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<28> PortForwardSourceRequest_class_data_ =
    PortForwardSourceRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PortForwardSourceRequest::GetClassData() const {
  return PortForwardSourceRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2>
PortForwardSourceRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PortForwardSourceRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::PortForwardSourceRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .ut.SocketEndpoint source = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.source_)}},
    // optional .ut.SocketEndpoint destination = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 2, 1,
      PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.destination_)}},
    // optional string environmentvariable = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.environmentvariable_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .ut.SocketEndpoint source = 1;
    {PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.source_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .ut.SocketEndpoint destination = 2;
    {PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.destination_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional string environmentvariable = 3;
    {PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.environmentvariable_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::ut::SocketEndpoint>()},
      {::_pbi::TcParser::GetTable<::ut::SocketEndpoint>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PortForwardSourceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.PortForwardSourceRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.environmentvariable_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.source_ != nullptr);
      _impl_.source_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.destination_ != nullptr);
      _impl_.destination_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PortForwardSourceRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PortForwardSourceRequest& this_ = static_cast<const PortForwardSourceRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PortForwardSourceRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PortForwardSourceRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.PortForwardSourceRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .ut.SocketEndpoint source = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.source_, this_._impl_.source_->GetCachedSize(), target,
        stream);
  }

  // optional .ut.SocketEndpoint destination = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.destination_, this_._impl_.destination_->GetCachedSize(), target,
        stream);
  }

  // optional string environmentvariable = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_environmentvariable();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.PortForwardSourceRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PortForwardSourceRequest::ByteSizeLong(const MessageLite& base) {
  const PortForwardSourceRequest& this_ = static_cast<const PortForwardSourceRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PortForwardSourceRequest::ByteSizeLong() const {
  const PortForwardSourceRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.PortForwardSourceRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional string environmentvariable = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_environmentvariable());
    }
    // optional .ut.SocketEndpoint source = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.source_);
    }
    // optional .ut.SocketEndpoint destination = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.destination_);
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PortForwardSourceRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PortForwardSourceRequest*>(&to_msg);
  auto& from = static_cast<const PortForwardSourceRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.PortForwardSourceRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_environmentvariable(from._internal_environmentvariable());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.source_ != nullptr);
      if (_this->_impl_.source_ == nullptr) {
        _this->_impl_.source_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.source_);
      } else {
        _this->_impl_.source_->MergeFrom(*from._impl_.source_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.destination_ != nullptr);
      if (_this->_impl_.destination_ == nullptr) {
        _this->_impl_.destination_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.destination_);
      } else {
        _this->_impl_.destination_->MergeFrom(*from._impl_.destination_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PortForwardSourceRequest::CopyFrom(const PortForwardSourceRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.PortForwardSourceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PortForwardSourceRequest::InternalSwap(PortForwardSourceRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.environmentvariable_, &other->_impl_.environmentvariable_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.destination_)
      + sizeof(PortForwardSourceRequest::_impl_.destination_)
      - PROTOBUF_FIELD_OFFSET(PortForwardSourceRequest, _impl_.source_)>(
          reinterpret_cast<char*>(&_impl_.source_),
          reinterpret_cast<char*>(&other->_impl_.source_));
}

// ===================================================================

class PortForwardSourceResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PortForwardSourceResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PortForwardSourceResponse, _impl_._has_bits_);
};

PortForwardSourceResponse::PortForwardSourceResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardSourceResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.PortForwardSourceResponse)
}
PROTOBUF_NDEBUG_INLINE PortForwardSourceResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::PortForwardSourceResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_(arena, from.error_) {}

PortForwardSourceResponse::PortForwardSourceResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PortForwardSourceResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardSourceResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PortForwardSourceResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:ut.PortForwardSourceResponse)
}
PROTOBUF_NDEBUG_INLINE PortForwardSourceResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        error_(arena) {}

inline void PortForwardSourceResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PortForwardSourceResponse::~PortForwardSourceResponse() {
  // @@protoc_insertion_point(destructor:ut.PortForwardSourceResponse)
  SharedDtor(*this);
}
inline void PortForwardSourceResponse::SharedDtor(MessageLite& self) {
  PortForwardSourceResponse& this_ = static_cast<PortForwardSourceResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.error_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PortForwardSourceResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PortForwardSourceResponse(arena);
}
constexpr auto PortForwardSourceResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PortForwardSourceResponse),
                                            alignof(PortForwardSourceResponse));
}
constexpr auto PortForwardSourceResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<29>{
      {
          &_PortForwardSourceResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PortForwardSourceResponse::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PortForwardSourceResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PortForwardSourceResponse::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PortForwardSourceResponse>(), &PortForwardSourceResponse::ByteSizeLong,
              &PortForwardSourceResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PortForwardSourceResponse, _impl_._cached_size_),
          true,
      },
      "ut.PortForwardSourceResponse",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<29> PortForwardSourceResponse_class_data_ =
    PortForwardSourceResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PortForwardSourceResponse::GetClassData() const {
  return PortForwardSourceResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
PortForwardSourceResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PortForwardSourceResponse, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PortForwardSourceResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::PortForwardSourceResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string error = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardSourceResponse, _impl_.error_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string error = 1;
    {PROTOBUF_FIELD_OFFSET(PortForwardSourceResponse, _impl_.error_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PortForwardSourceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.PortForwardSourceResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PortForwardSourceResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PortForwardSourceResponse& this_ = static_cast<const PortForwardSourceResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PortForwardSourceResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PortForwardSourceResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.PortForwardSourceResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string error = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_error();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.PortForwardSourceResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PortForwardSourceResponse::ByteSizeLong(const MessageLite& base) {
  const PortForwardSourceResponse& this_ = static_cast<const PortForwardSourceResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PortForwardSourceResponse::ByteSizeLong() const {
  const PortForwardSourceResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.PortForwardSourceResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional string error = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_error());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PortForwardSourceResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PortForwardSourceResponse*>(&to_msg);
  auto& from = static_cast<const PortForwardSourceResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.PortForwardSourceResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_internal_set_error(from._internal_error());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PortForwardSourceResponse::CopyFrom(const PortForwardSourceResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.PortForwardSourceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PortForwardSourceResponse::InternalSwap(PortForwardSourceResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, &other->_impl_.error_, arena);
}

// ===================================================================

class PortForwardDestinationRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PortForwardDestinationRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_._has_bits_);
};

void PortForwardDestinationRequest::clear_destination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.destination_ != nullptr) _impl_.destination_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
PortForwardDestinationRequest::PortForwardDestinationRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardDestinationRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.PortForwardDestinationRequest)
}
PROTOBUF_NDEBUG_INLINE PortForwardDestinationRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::PortForwardDestinationRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PortForwardDestinationRequest::PortForwardDestinationRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PortForwardDestinationRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardDestinationRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PortForwardDestinationRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.destination_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.destination_)
                : nullptr;
  _impl_.fd_ = from._impl_.fd_;

  // @@protoc_insertion_point(copy_constructor:ut.PortForwardDestinationRequest)
}
PROTOBUF_NDEBUG_INLINE PortForwardDestinationRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PortForwardDestinationRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, destination_),
           0,
           offsetof(Impl_, fd_) -
               offsetof(Impl_, destination_) +
               sizeof(Impl_::fd_));
}
PortForwardDestinationRequest::~PortForwardDestinationRequest() {
  // @@protoc_insertion_point(destructor:ut.PortForwardDestinationRequest)
  SharedDtor(*this);
}
inline void PortForwardDestinationRequest::SharedDtor(MessageLite& self) {
  PortForwardDestinationRequest& this_ = static_cast<PortForwardDestinationRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.destination_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PortForwardDestinationRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PortForwardDestinationRequest(arena);
}
constexpr auto PortForwardDestinationRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PortForwardDestinationRequest),
                                            alignof(PortForwardDestinationRequest));
}
constexpr auto PortForwardDestinationRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<33>{
      {
          &_PortForwardDestinationRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PortForwardDestinationRequest::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PortForwardDestinationRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PortForwardDestinationRequest::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PortForwardDestinationRequest>(), &PortForwardDestinationRequest::ByteSizeLong,
              &PortForwardDestinationRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_._cached_size_),
          true,
      },
      "ut.PortForwardDestinationRequest",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<33> PortForwardDestinationRequest_class_data_ =
    PortForwardDestinationRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PortForwardDestinationRequest::GetClassData() const {
  return PortForwardDestinationRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
PortForwardDestinationRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PortForwardDestinationRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::PortForwardDestinationRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 fd = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_.fd_)}},
    // optional .ut.SocketEndpoint destination = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_.destination_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .ut.SocketEndpoint destination = 1;
    {PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_.destination_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 fd = 2;
    {PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_.fd_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::ut::SocketEndpoint>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PortForwardDestinationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.PortForwardDestinationRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(_impl_.destination_ != nullptr);
    _impl_.destination_->Clear();
  }
  _impl_.fd_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PortForwardDestinationRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PortForwardDestinationRequest& this_ = static_cast<const PortForwardDestinationRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PortForwardDestinationRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PortForwardDestinationRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.PortForwardDestinationRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .ut.SocketEndpoint destination = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.destination_, this_._impl_.destination_->GetCachedSize(), target,
        stream);
  }

  // optional int32 fd = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_fd(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.PortForwardDestinationRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PortForwardDestinationRequest::ByteSizeLong(const MessageLite& base) {
  const PortForwardDestinationRequest& this_ = static_cast<const PortForwardDestinationRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PortForwardDestinationRequest::ByteSizeLong() const {
  const PortForwardDestinationRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.PortForwardDestinationRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional .ut.SocketEndpoint destination = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.destination_);
    }
    // optional int32 fd = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_fd());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PortForwardDestinationRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PortForwardDestinationRequest*>(&to_msg);
  auto& from = static_cast<const PortForwardDestinationRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.PortForwardDestinationRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.destination_ != nullptr);
      if (_this->_impl_.destination_ == nullptr) {
        _this->_impl_.destination_ = ::google::protobuf::MessageLite::CopyConstruct(arena, *from._impl_.destination_);
      } else {
        _this->_impl_.destination_->MergeFrom(*from._impl_.destination_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.fd_ = from._impl_.fd_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PortForwardDestinationRequest::CopyFrom(const PortForwardDestinationRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.PortForwardDestinationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PortForwardDestinationRequest::InternalSwap(PortForwardDestinationRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_.fd_)
      + sizeof(PortForwardDestinationRequest::_impl_.fd_)
      - PROTOBUF_FIELD_OFFSET(PortForwardDestinationRequest, _impl_.destination_)>(
          reinterpret_cast<char*>(&_impl_.destination_),
          reinterpret_cast<char*>(&other->_impl_.destination_));
}

// ===================================================================

class PortForwardDestinationResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PortForwardDestinationResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_._has_bits_);
};

PortForwardDestinationResponse::PortForwardDestinationResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardDestinationResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.PortForwardDestinationResponse)
}
PROTOBUF_NDEBUG_INLINE PortForwardDestinationResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::PortForwardDestinationResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_(arena, from.error_) {}

PortForwardDestinationResponse::PortForwardDestinationResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PortForwardDestinationResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardDestinationResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PortForwardDestinationResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, clientfd_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, clientfd_),
           offsetof(Impl_, socketid_) -
               offsetof(Impl_, clientfd_) +
               sizeof(Impl_::socketid_));

  // @@protoc_insertion_point(copy_constructor:ut.PortForwardDestinationResponse)
}
PROTOBUF_NDEBUG_INLINE PortForwardDestinationResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        error_(arena) {}

inline void PortForwardDestinationResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, clientfd_),
           0,
           offsetof(Impl_, socketid_) -
               offsetof(Impl_, clientfd_) +
               sizeof(Impl_::socketid_));
}
PortForwardDestinationResponse::~PortForwardDestinationResponse() {
  // @@protoc_insertion_point(destructor:ut.PortForwardDestinationResponse)
  SharedDtor(*this);
}
inline void PortForwardDestinationResponse::SharedDtor(MessageLite& self) {
  PortForwardDestinationResponse& this_ = static_cast<PortForwardDestinationResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.error_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PortForwardDestinationResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PortForwardDestinationResponse(arena);
}
constexpr auto PortForwardDestinationResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PortForwardDestinationResponse),
                                            alignof(PortForwardDestinationResponse));
}
constexpr auto PortForwardDestinationResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<34>{
      {
          &_PortForwardDestinationResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PortForwardDestinationResponse::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PortForwardDestinationResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PortForwardDestinationResponse::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PortForwardDestinationResponse>(), &PortForwardDestinationResponse::ByteSizeLong,
              &PortForwardDestinationResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_._cached_size_),
          true,
      },
      "ut.PortForwardDestinationResponse",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<34> PortForwardDestinationResponse_class_data_ =
    PortForwardDestinationResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PortForwardDestinationResponse::GetClassData() const {
  return PortForwardDestinationResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
PortForwardDestinationResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PortForwardDestinationResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::PortForwardDestinationResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 clientfd = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.clientfd_)}},
    // optional int32 socketid = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.socketid_)}},
    // optional string error = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.error_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 clientfd = 1;
    {PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.clientfd_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 socketid = 2;
    {PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.socketid_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional string error = 3;
    {PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.error_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PortForwardDestinationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.PortForwardDestinationResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    ::memset(&_impl_.clientfd_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.socketid_) -
        reinterpret_cast<char*>(&_impl_.clientfd_)) + sizeof(_impl_.socketid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PortForwardDestinationResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PortForwardDestinationResponse& this_ = static_cast<const PortForwardDestinationResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PortForwardDestinationResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PortForwardDestinationResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.PortForwardDestinationResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 clientfd = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_clientfd(), target);
  }

  // optional int32 socketid = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_socketid(), target);
  }

  // optional string error = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_error();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.PortForwardDestinationResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PortForwardDestinationResponse::ByteSizeLong(const MessageLite& base) {
  const PortForwardDestinationResponse& this_ = static_cast<const PortForwardDestinationResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PortForwardDestinationResponse::ByteSizeLong() const {
  const PortForwardDestinationResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.PortForwardDestinationResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional string error = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_error());
    }
    // optional int32 clientfd = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_clientfd());
    }
    // optional int32 socketid = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_socketid());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PortForwardDestinationResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PortForwardDestinationResponse*>(&to_msg);
  auto& from = static_cast<const PortForwardDestinationResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.PortForwardDestinationResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_error(from._internal_error());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.clientfd_ = from._impl_.clientfd_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.socketid_ = from._impl_.socketid_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PortForwardDestinationResponse::CopyFrom(const PortForwardDestinationResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.PortForwardDestinationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PortForwardDestinationResponse::InternalSwap(PortForwardDestinationResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, &other->_impl_.error_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.socketid_)
      + sizeof(PortForwardDestinationResponse::_impl_.socketid_)
      - PROTOBUF_FIELD_OFFSET(PortForwardDestinationResponse, _impl_.clientfd_)>(
          reinterpret_cast<char*>(&_impl_.clientfd_),
          reinterpret_cast<char*>(&other->_impl_.clientfd_));
}

// ===================================================================

class PortForwardData::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PortForwardData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_._has_bits_);
};

PortForwardData::PortForwardData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardData_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.PortForwardData)
}
PROTOBUF_NDEBUG_INLINE PortForwardData::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::PortForwardData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        buffer_(arena, from.buffer_),
        error_(arena, from.error_) {}

PortForwardData::PortForwardData(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PortForwardData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, PortForwardData_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PortForwardData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, socketid_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, socketid_),
           offsetof(Impl_, closed_) -
               offsetof(Impl_, socketid_) +
               sizeof(Impl_::closed_));

  // @@protoc_insertion_point(copy_constructor:ut.PortForwardData)
}
PROTOBUF_NDEBUG_INLINE PortForwardData::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        buffer_(arena),
        error_(arena) {}

inline void PortForwardData::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, socketid_),
           0,
           offsetof(Impl_, closed_) -
               offsetof(Impl_, socketid_) +
               sizeof(Impl_::closed_));
}
PortForwardData::~PortForwardData() {
  // @@protoc_insertion_point(destructor:ut.PortForwardData)
  SharedDtor(*this);
}
inline void PortForwardData::SharedDtor(MessageLite& self) {
  PortForwardData& this_ = static_cast<PortForwardData&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.buffer_.Destroy();
  this_._impl_.error_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PortForwardData::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PortForwardData(arena);
}
constexpr auto PortForwardData::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PortForwardData),
                                            alignof(PortForwardData));
}
constexpr auto PortForwardData::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<19>{
      {
          &_PortForwardData_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PortForwardData::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<PortForwardData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PortForwardData::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<PortForwardData>(), &PortForwardData::ByteSizeLong,
              &PortForwardData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_._cached_size_),
          true,
      },
      "ut.PortForwardData",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<19> PortForwardData_class_data_ =
    PortForwardData::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PortForwardData::GetClassData() const {
  return PortForwardData_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
PortForwardData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PortForwardData_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::PortForwardData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool sourcetodestination = 1;
    {::_pbi::TcParser::FastV8S1,
     {8, 3, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.sourcetodestination_)}},
    // optional int32 socketid = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.socketid_)}},
    // optional bytes buffer = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.buffer_)}},
    // optional string error = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.error_)}},
    // optional bool closed = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.closed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool sourcetodestination = 1;
    {PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.sourcetodestination_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 socketid = 2;
    {PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.socketid_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bytes buffer = 3;
    {PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.buffer_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string error = 4;
    {PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.error_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool closed = 5;
    {PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.closed_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PortForwardData::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.PortForwardData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.buffer_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001cU)) {
    ::memset(&_impl_.socketid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.closed_) -
        reinterpret_cast<char*>(&_impl_.socketid_)) + sizeof(_impl_.closed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PortForwardData::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PortForwardData& this_ = static_cast<const PortForwardData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PortForwardData::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PortForwardData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.PortForwardData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool sourcetodestination = 1;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_sourcetodestination(), target);
  }

  // optional int32 socketid = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_socketid(), target);
  }

  // optional bytes buffer = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_buffer();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional string error = 4;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_error();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional bool closed = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_closed(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.PortForwardData)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PortForwardData::ByteSizeLong(const MessageLite& base) {
  const PortForwardData& this_ = static_cast<const PortForwardData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PortForwardData::ByteSizeLong() const {
  const PortForwardData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.PortForwardData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000018U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional bytes buffer = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_buffer());
    }
    // optional string error = 4;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_error());
    }
    // optional int32 socketid = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_socketid());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void PortForwardData::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PortForwardData*>(&to_msg);
  auto& from = static_cast<const PortForwardData&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.PortForwardData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_buffer(from._internal_buffer());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_error(from._internal_error());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.socketid_ = from._impl_.socketid_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.sourcetodestination_ = from._impl_.sourcetodestination_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.closed_ = from._impl_.closed_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void PortForwardData::CopyFrom(const PortForwardData& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.PortForwardData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PortForwardData::InternalSwap(PortForwardData* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.buffer_, &other->_impl_.buffer_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, &other->_impl_.error_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.closed_)
      + sizeof(PortForwardData::_impl_.closed_)
      - PROTOBUF_FIELD_OFFSET(PortForwardData, _impl_.socketid_)>(
          reinterpret_cast<char*>(&_impl_.socketid_),
          reinterpret_cast<char*>(&other->_impl_.socketid_));
}

// ===================================================================

// ===================================================================

class InitialPayload::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<InitialPayload>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_._has_bits_);
};

InitialPayload::InitialPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, InitialPayload_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.InitialPayload)
}
PROTOBUF_NDEBUG_INLINE InitialPayload::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::InitialPayload& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reversetunnels_{visibility, arena, from.reversetunnels_},
        environmentvariables_{visibility, arena, from.environmentvariables_} {}

InitialPayload::InitialPayload(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const InitialPayload& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, InitialPayload_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InitialPayload* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.jumphost_ = from._impl_.jumphost_;

  // @@protoc_insertion_point(copy_constructor:ut.InitialPayload)
}
PROTOBUF_NDEBUG_INLINE InitialPayload::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reversetunnels_{visibility, arena},
        environmentvariables_{visibility, arena} {}

inline void InitialPayload::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.jumphost_ = {};
}
InitialPayload::~InitialPayload() {
  // @@protoc_insertion_point(destructor:ut.InitialPayload)
  SharedDtor(*this);
}
inline void InitialPayload::SharedDtor(MessageLite& self) {
  InitialPayload& this_ = static_cast<InitialPayload&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL InitialPayload::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) InitialPayload(arena);
}
constexpr auto InitialPayload::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.reversetunnels_) +
          decltype(InitialPayload::_impl_.reversetunnels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.environmentvariables_) +
          decltype(InitialPayload::_impl_.environmentvariables_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(InitialPayload), alignof(InitialPayload), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&InitialPayload::PlacementNew_,
                                 sizeof(InitialPayload),
                                 alignof(InitialPayload));
  }
}
constexpr auto InitialPayload::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<18>{
      {
          &_InitialPayload_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &InitialPayload::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<InitialPayload>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &InitialPayload::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<InitialPayload>(), &InitialPayload::ByteSizeLong,
              &InitialPayload::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_._cached_size_),
          true,
      },
      "ut.InitialPayload",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<18> InitialPayload_class_data_ =
    InitialPayload::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
InitialPayload::GetClassData() const {
  return InitialPayload_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 3, 2, 0, 2>
InitialPayload::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_._has_bits_),
    0, // no _extensions_
    3, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    InitialPayload_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::InitialPayload>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .ut.PortForwardSourceRequest reversetunnels = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.reversetunnels_)}},
    // optional bool jumphost = 1 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.jumphost_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool jumphost = 1 [default = false];
    {PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.jumphost_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .ut.PortForwardSourceRequest reversetunnels = 2;
    {PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.reversetunnels_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // map<string, string> environmentvariables = 3;
    {PROTOBUF_FIELD_OFFSET(InitialPayload, _impl_.environmentvariables_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::ut::PortForwardSourceRequest>()},
      {::_pbi::TcParser::GetMapAuxInfo(
          0, 0, 9, 9, 1)},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void InitialPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.InitialPayload)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.reversetunnels_.Clear();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    _impl_.jumphost_ = false;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.environmentvariables_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL InitialPayload::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const InitialPayload& this_ = static_cast<const InitialPayload&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL InitialPayload::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const InitialPayload& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.InitialPayload)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool jumphost = 1 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_jumphost(), target);
  }

  // repeated .ut.PortForwardSourceRequest reversetunnels = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_reversetunnels_size());
         i < n; i++) {
      const auto& repfield = this_._internal_reversetunnels().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // map<string, string> environmentvariables = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_environmentvariables().empty()) {
      using MapType = ::google::protobuf::Map<::std::string, ::std::string>;
      using WireHelper = _pbi::MapEntryFuncs<::std::string, ::std::string,
                                     _pbi::WireFormatLite::TYPE_STRING,
                                     _pbi::WireFormatLite::TYPE_STRING>;
      const auto& field = this_._internal_environmentvariables();

      if (stream->IsSerializationDeterministic() && field.size() > 1) {
        for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
          target = WireHelper::InternalSerialize(
              3, entry.first, entry.second, target, stream);
        }
      } else {
        for (const auto& entry : field) {
          target = WireHelper::InternalSerialize(
              3, entry.first, entry.second, target, stream);
        }
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.InitialPayload)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t InitialPayload::ByteSizeLong(const MessageLite& base) {
  const InitialPayload& this_ = static_cast<const InitialPayload&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t InitialPayload::ByteSizeLong() const {
  const InitialPayload& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.InitialPayload)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000002U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000005U)) {
    // repeated .ut.PortForwardSourceRequest reversetunnels = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_reversetunnels_size();
      for (const auto& msg : this_._internal_reversetunnels()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // map<string, string> environmentvariables = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_environmentvariables_size());
      for (const auto& entry : this_._internal_environmentvariables()) {
        total_size += _pbi::MapEntryFuncs<::std::string, ::std::string,
                                       _pbi::WireFormatLite::TYPE_STRING,
                                       _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
      }
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void InitialPayload::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<InitialPayload*>(&to_msg);
  auto& from = static_cast<const InitialPayload&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.InitialPayload)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_reversetunnels()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_reversetunnels());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.jumphost_ = from._impl_.jumphost_;
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_impl_.environmentvariables_.MergeFrom(from._impl_.environmentvariables_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void InitialPayload::CopyFrom(const InitialPayload& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.InitialPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InitialPayload::InternalSwap(InitialPayload* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.reversetunnels_.InternalSwap(&other->_impl_.reversetunnels_);
  swap(_impl_.jumphost_, other->_impl_.jumphost_);
  _impl_.environmentvariables_.InternalSwap(&other->_impl_.environmentvariables_);
}

// ===================================================================

class InitialResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<InitialResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(InitialResponse, _impl_._has_bits_);
};

InitialResponse::InitialResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, InitialResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.InitialResponse)
}
PROTOBUF_NDEBUG_INLINE InitialResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::InitialResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_(arena, from.error_) {}

InitialResponse::InitialResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const InitialResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, InitialResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InitialResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:ut.InitialResponse)
}
PROTOBUF_NDEBUG_INLINE InitialResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        error_(arena) {}

inline void InitialResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
InitialResponse::~InitialResponse() {
  // @@protoc_insertion_point(destructor:ut.InitialResponse)
  SharedDtor(*this);
}
inline void InitialResponse::SharedDtor(MessageLite& self) {
  InitialResponse& this_ = static_cast<InitialResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.error_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL InitialResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) InitialResponse(arena);
}
constexpr auto InitialResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(InitialResponse),
                                            alignof(InitialResponse));
}
constexpr auto InitialResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<19>{
      {
          &_InitialResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &InitialResponse::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<InitialResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &InitialResponse::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<InitialResponse>(), &InitialResponse::ByteSizeLong,
              &InitialResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(InitialResponse, _impl_._cached_size_),
          true,
      },
      "ut.InitialResponse",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<19> InitialResponse_class_data_ =
    InitialResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
InitialResponse::GetClassData() const {
  return InitialResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
InitialResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InitialResponse, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    InitialResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::InitialResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string error = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(InitialResponse, _impl_.error_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string error = 1;
    {PROTOBUF_FIELD_OFFSET(InitialResponse, _impl_.error_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void InitialResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.InitialResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL InitialResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const InitialResponse& this_ = static_cast<const InitialResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL InitialResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const InitialResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.InitialResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string error = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_error();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.InitialResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t InitialResponse::ByteSizeLong(const MessageLite& base) {
  const InitialResponse& this_ = static_cast<const InitialResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t InitialResponse::ByteSizeLong() const {
  const InitialResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.InitialResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional string error = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_error());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void InitialResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<InitialResponse*>(&to_msg);
  auto& from = static_cast<const InitialResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.InitialResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_internal_set_error(from._internal_error());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void InitialResponse::CopyFrom(const InitialResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.InitialResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InitialResponse::InternalSwap(InitialResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, &other->_impl_.error_, arena);
}

// ===================================================================

class ConfigParams::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ConfigParams>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_._has_bits_);
};

ConfigParams::ConfigParams(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConfigParams_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.ConfigParams)
}
ConfigParams::ConfigParams(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConfigParams& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, ConfigParams_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE ConfigParams::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void ConfigParams::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, vlevel_),
           0,
           offsetof(Impl_, minloglevel_) -
               offsetof(Impl_, vlevel_) +
               sizeof(Impl_::minloglevel_));
}
ConfigParams::~ConfigParams() {
  // @@protoc_insertion_point(destructor:ut.ConfigParams)
  SharedDtor(*this);
}
inline void ConfigParams::SharedDtor(MessageLite& self) {
  ConfigParams& this_ = static_cast<ConfigParams&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ConfigParams::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ConfigParams(arena);
}
constexpr auto ConfigParams::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(ConfigParams),
                                            alignof(ConfigParams));
}
constexpr auto ConfigParams::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<16>{
      {
          &_ConfigParams_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ConfigParams::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<ConfigParams>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ConfigParams::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<ConfigParams>(), &ConfigParams::ByteSizeLong,
              &ConfigParams::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_._cached_size_),
          true,
      },
      "ut.ConfigParams",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<16> ConfigParams_class_data_ =
    ConfigParams::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ConfigParams::GetClassData() const {
  return ConfigParams_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
ConfigParams::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ConfigParams_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::ConfigParams>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional int32 minloglevel = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_.minloglevel_)}},
    // optional int32 vlevel = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_.vlevel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 vlevel = 1;
    {PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_.vlevel_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 minloglevel = 2;
    {PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_.minloglevel_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ConfigParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.ConfigParams)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    ::memset(&_impl_.vlevel_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.minloglevel_) -
        reinterpret_cast<char*>(&_impl_.vlevel_)) + sizeof(_impl_.minloglevel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ConfigParams::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ConfigParams& this_ = static_cast<const ConfigParams&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ConfigParams::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ConfigParams& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.ConfigParams)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 vlevel = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_vlevel(), target);
  }

  // optional int32 minloglevel = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_minloglevel(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.ConfigParams)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ConfigParams::ByteSizeLong(const MessageLite& base) {
  const ConfigParams& this_ = static_cast<const ConfigParams&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ConfigParams::ByteSizeLong() const {
  const ConfigParams& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.ConfigParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional int32 vlevel = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_vlevel());
    }
    // optional int32 minloglevel = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_minloglevel());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void ConfigParams::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ConfigParams*>(&to_msg);
  auto& from = static_cast<const ConfigParams&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.ConfigParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.vlevel_ = from._impl_.vlevel_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.minloglevel_ = from._impl_.minloglevel_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void ConfigParams::CopyFrom(const ConfigParams& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.ConfigParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ConfigParams::InternalSwap(ConfigParams* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_.minloglevel_)
      + sizeof(ConfigParams::_impl_.minloglevel_)
      - PROTOBUF_FIELD_OFFSET(ConfigParams, _impl_.vlevel_)>(
          reinterpret_cast<char*>(&_impl_.vlevel_),
          reinterpret_cast<char*>(&other->_impl_.vlevel_));
}

// ===================================================================

class TermInit::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TermInit>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TermInit, _impl_._has_bits_);
};

TermInit::TermInit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TermInit_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.TermInit)
}
PROTOBUF_NDEBUG_INLINE TermInit::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::TermInit& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        environmentnames_{visibility, arena, from.environmentnames_},
        environmentvalues_{visibility, arena, from.environmentvalues_} {}

TermInit::TermInit(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TermInit& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TermInit_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TermInit* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:ut.TermInit)
}
PROTOBUF_NDEBUG_INLINE TermInit::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        environmentnames_{visibility, arena},
        environmentvalues_{visibility, arena} {}

inline void TermInit::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TermInit::~TermInit() {
  // @@protoc_insertion_point(destructor:ut.TermInit)
  SharedDtor(*this);
}
inline void TermInit::SharedDtor(MessageLite& self) {
  TermInit& this_ = static_cast<TermInit&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TermInit::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TermInit(arena);
}
constexpr auto TermInit::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TermInit, _impl_.environmentnames_) +
          decltype(TermInit::_impl_.environmentnames_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TermInit, _impl_.environmentvalues_) +
          decltype(TermInit::_impl_.environmentvalues_)::
              InternalGetArenaOffset(
                  ::google::protobuf::MessageLite::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(TermInit), alignof(TermInit), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TermInit::PlacementNew_,
                                 sizeof(TermInit),
                                 alignof(TermInit));
  }
}
constexpr auto TermInit::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<12>{
      {
          &_TermInit_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TermInit::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<TermInit>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TermInit::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<TermInit>(), &TermInit::ByteSizeLong,
              &TermInit::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TermInit, _impl_._cached_size_),
          true,
      },
      "ut.TermInit",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<12> TermInit_class_data_ =
    TermInit::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TermInit::GetClassData() const {
  return TermInit_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
TermInit::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TermInit, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TermInit_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::TermInit>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated string environmentvalues = 2;
    {::_pbi::TcParser::FastBR1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(TermInit, _impl_.environmentvalues_)}},
    // repeated string environmentnames = 1;
    {::_pbi::TcParser::FastBR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TermInit, _impl_.environmentnames_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string environmentnames = 1;
    {PROTOBUF_FIELD_OFFSET(TermInit, _impl_.environmentnames_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // repeated string environmentvalues = 2;
    {PROTOBUF_FIELD_OFFSET(TermInit, _impl_.environmentvalues_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void TermInit::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.TermInit)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.environmentnames_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.environmentvalues_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TermInit::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TermInit& this_ = static_cast<const TermInit&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TermInit::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TermInit& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.TermInit)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated string environmentnames = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_environmentnames_size(); i < n; ++i) {
      const auto& s = this_._internal_environmentnames().Get(i);
      target = stream->WriteString(1, s, target);
    }
  }

  // repeated string environmentvalues = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_environmentvalues_size(); i < n; ++i) {
      const auto& s = this_._internal_environmentvalues().Get(i);
      target = stream->WriteString(2, s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.TermInit)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TermInit::ByteSizeLong(const MessageLite& base) {
  const TermInit& this_ = static_cast<const TermInit&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TermInit::ByteSizeLong() const {
  const TermInit& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.TermInit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated string environmentnames = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_environmentnames().size());
      for (int i = 0, n = this_._internal_environmentnames().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_environmentnames().Get(i));
      }
    }
    // repeated string environmentvalues = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_environmentvalues().size());
      for (int i = 0, n = this_._internal_environmentvalues().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_environmentvalues().Get(i));
      }
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void TermInit::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TermInit*>(&to_msg);
  auto& from = static_cast<const TermInit&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.TermInit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_environmentnames()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_environmentnames());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_environmentvalues()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_environmentvalues());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void TermInit::CopyFrom(const TermInit& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.TermInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TermInit::InternalSwap(TermInit* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.environmentnames_.InternalSwap(&other->_impl_.environmentnames_);
  _impl_.environmentvalues_.InternalSwap(&other->_impl_.environmentvalues_);
}

// ===================================================================

class TerminalUserInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TerminalUserInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_._has_bits_);
};

TerminalUserInfo::TerminalUserInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TerminalUserInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ut.TerminalUserInfo)
}
PROTOBUF_NDEBUG_INLINE TerminalUserInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::ut::TerminalUserInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_),
        passkey_(arena, from.passkey_) {}

TerminalUserInfo::TerminalUserInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TerminalUserInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::MessageLite(arena, TerminalUserInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::MessageLite(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TerminalUserInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, uid_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, uid_),
           offsetof(Impl_, fd_) -
               offsetof(Impl_, uid_) +
               sizeof(Impl_::fd_));

  // @@protoc_insertion_point(copy_constructor:ut.TerminalUserInfo)
}
PROTOBUF_NDEBUG_INLINE TerminalUserInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        id_(arena),
        passkey_(arena) {}

inline void TerminalUserInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, uid_),
           0,
           offsetof(Impl_, fd_) -
               offsetof(Impl_, uid_) +
               sizeof(Impl_::fd_));
}
TerminalUserInfo::~TerminalUserInfo() {
  // @@protoc_insertion_point(destructor:ut.TerminalUserInfo)
  SharedDtor(*this);
}
inline void TerminalUserInfo::SharedDtor(MessageLite& self) {
  TerminalUserInfo& this_ = static_cast<TerminalUserInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::std::string>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.passkey_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TerminalUserInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TerminalUserInfo(arena);
}
constexpr auto TerminalUserInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TerminalUserInfo),
                                            alignof(TerminalUserInfo));
}
constexpr auto TerminalUserInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataLite<20>{
      {
          &_TerminalUserInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TerminalUserInfo::MergeImpl,
          ::google::protobuf::MessageLite::GetNewImpl<TerminalUserInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TerminalUserInfo::SharedDtor,
          ::google::protobuf::MessageLite::GetClearImpl<TerminalUserInfo>(), &TerminalUserInfo::ByteSizeLong,
              &TerminalUserInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_._cached_size_),
          true,
      },
      "ut.TerminalUserInfo",
  };
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataLite<20> TerminalUserInfo_class_data_ =
    TerminalUserInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TerminalUserInfo::GetClassData() const {
  return TerminalUserInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
TerminalUserInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TerminalUserInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::ut::TerminalUserInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string id = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.id_)}},
    // optional string passkey = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.passkey_)}},
    // optional int64 uid = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.uid_)}},
    // optional int64 gid = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.gid_)}},
    // optional int64 fd = 5;
    {::_pbi::TcParser::FastV64S1,
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.fd_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string id = 1;
    {PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string passkey = 2;
    {PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.passkey_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 uid = 3;
    {PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.uid_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 gid = 4;
    {PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.gid_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 fd = 5;
    {PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.fd_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void TerminalUserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ut.TerminalUserInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.passkey_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001cU)) {
    ::memset(&_impl_.uid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.fd_) -
        reinterpret_cast<char*>(&_impl_.uid_)) + sizeof(_impl_.fd_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::std::string>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TerminalUserInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TerminalUserInfo& this_ = static_cast<const TerminalUserInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TerminalUserInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TerminalUserInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:ut.TerminalUserInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string passkey = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_passkey();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int64 uid = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<3>(
            stream, this_._internal_uid(), target);
  }

  // optional int64 gid = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<4>(
            stream, this_._internal_gid(), target);
  }

  // optional int64 fd = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<5>(
            stream, this_._internal_fd(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ut.TerminalUserInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TerminalUserInfo::ByteSizeLong(const MessageLite& base) {
  const TerminalUserInfo& this_ = static_cast<const TerminalUserInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TerminalUserInfo::ByteSizeLong() const {
  const TerminalUserInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:ut.TerminalUserInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // optional string id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_id());
    }
    // optional string passkey = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_passkey());
    }
    // optional int64 uid = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_uid());
    }
    // optional int64 gid = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_gid());
    }
    // optional int64 fd = 5;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_fd());
    }
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    total_size += this_._internal_metadata_.unknown_fields<::std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  this_._impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void TerminalUserInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TerminalUserInfo*>(&to_msg);
  auto& from = static_cast<const TerminalUserInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:ut.TerminalUserInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_id(from._internal_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_passkey(from._internal_passkey());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.fd_ = from._impl_.fd_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::std::string>(
      from._internal_metadata_);
}

void TerminalUserInfo::CopyFrom(const TerminalUserInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:ut.TerminalUserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TerminalUserInfo::InternalSwap(TerminalUserInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.passkey_, &other->_impl_.passkey_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.fd_)
      + sizeof(TerminalUserInfo::_impl_.fd_)
      - PROTOBUF_FIELD_OFFSET(TerminalUserInfo, _impl_.uid_)>(
          reinterpret_cast<char*>(&_impl_.uid_),
          reinterpret_cast<char*>(&other->_impl_.uid_));
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace ut
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
